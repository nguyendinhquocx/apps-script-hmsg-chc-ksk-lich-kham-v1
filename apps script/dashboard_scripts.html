<script>
// Utility functions
function isSunday(date) {
  return date.getDay() === 0;
}

// Global state x.
let currentMonth = new Date().getMonth() + 1;
let currentYear = new Date().getFullYear();

let showGold = false;
let searchCompany = '';
let filterEmployee = '';
let shiftFilter = 'total'; // M·∫∑c ƒë·ªãnh l√† T·ªïng
let timeFilter = 'all'; // M·∫∑c ƒë·ªãnh l√† T·∫•t c·∫£ th·ªùi gian
let dashboardData = null;
let originalData = null; // Keep original unfiltered data
let clinicalData = null;

// Chart instances
let totalPeopleChart = null;
let clinicalMaxChart = null;

// Debounce variables v·ªõi t·ªëi ∆∞u h√≥a - t√°ch ri√™ng cho t·ª´ng filter
let searchDebounceTimer = null;
let employeeDebounceTimer = null;
let shiftDebounceTimer = null;
let timeDebounceTimer = null;
let goldDebounceTimer = null;
const DEBOUNCE_DELAY = 500; // TƒÉng l√™n 500ms ƒë·ªÉ tr√°nh spam requests

// Cache v√† performance optimization
let dataCache = {};
let lastLoadTime = 0;
const CACHE_DURATION = 30000; // 30 gi√¢y cache
let isLoading = false;
let pendingRequests = 0;

// Auto clear cache ƒë·ªÉ tr√°nh memory leak
setInterval(() => {
  const now = Date.now();
  const cacheKeys = Object.keys(dataCache);
  
  // Clear cache entries older than CACHE_DURATION
  cacheKeys.forEach(key => {
    if (now - lastLoadTime > CACHE_DURATION) {
      delete dataCache[key];
    }
  });
  
  // Log cache status
  if (cacheKeys.length > 5) {
    console.log('üßπ Cache cleanup: removed old entries');
    dataCache = {}; // Clear all if too many entries
  }
}, 60000); // Check every minute

// Initialize v·ªõi safety mechanism
document.addEventListener('DOMContentLoaded', function() {
  initializeApp();
  loadCurrentMonth();
});

function initializeApp() {
  // Month navigation
  document.getElementById('prevMonth').addEventListener('click', () => {
    navigateMonth(-1);
  });
  
  document.getElementById('nextMonth').addEventListener('click', () => {
    navigateMonth(1);
  });
  
  // Search input - debounced search v·ªõi timer ri√™ng
  const searchInput = document.getElementById('companySearch');
  searchInput.addEventListener('input', (e) => {
    const value = e.target.value.trim();
    
    // Clear previous search timer
    if (searchDebounceTimer) {
      clearTimeout(searchDebounceTimer);
    }
    
    // Set new search timer
    searchDebounceTimer = setTimeout(() => {
      searchCompany = value;
      console.log('üîç Search filter changed:', searchCompany);
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Also handle Enter key for immediate search
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      if (searchDebounceTimer) {
        clearTimeout(searchDebounceTimer);
      }
      searchCompany = e.target.value.trim();
      console.log('üîç Search filter (Enter):', searchCompany);
      loadDataWithCurrentFilters();
    }
  });
  
  // Employee filter - v·ªõi timer ri√™ng
  document.getElementById('employeeFilter').addEventListener('change', (e) => {
    filterEmployee = e.target.value;
    console.log('üë§ Employee filter changed:', filterEmployee);
    
    // Clear previous employee timer
    if (employeeDebounceTimer) {
      clearTimeout(employeeDebounceTimer);
    }
    
    // Set employee timer
    employeeDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Shift filter - v·ªõi timer ri√™ng
  document.getElementById('shiftFilter').addEventListener('change', (e) => {
    shiftFilter = e.target.value;
    console.log('üîß Shift filter changed:', shiftFilter);
    
    // Clear previous shift timer
    if (shiftDebounceTimer) {
      clearTimeout(shiftDebounceTimer);
    }
    
    shiftDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Time filter - v·ªõi timer ri√™ng
  document.getElementById('timeFilter').addEventListener('change', (e) => {
    timeFilter = e.target.value;
    console.log('‚è∞ Time filter changed:', timeFilter);
    
    // Clear previous time timer
    if (timeDebounceTimer) {
      clearTimeout(timeDebounceTimer);
    }
    
    timeDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Gold filter checkbox - v·ªõi timer ri√™ng
  document.getElementById('showGold').addEventListener('change', (e) => {
    showGold = e.target.checked;
    console.log('‚≠ê Gold filter changed:', showGold);
    
    // Clear previous gold timer
    if (goldDebounceTimer) {
      clearTimeout(goldDebounceTimer);
    }
    
    goldDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  updateMonthDisplay();
}

function navigateMonth(direction) {
  // Clear cache khi chuy·ªÉn th√°ng ƒë·ªÉ tr√°nh hi·ªÉn th·ªã d·ªØ li·ªáu c≈©
  dataCache = {};
  lastLoadTime = 0;
  
  currentMonth += direction;
  
  if (currentMonth > 12) {
    currentMonth = 1;
    currentYear++;
  } else if (currentMonth < 1) {
    currentMonth = 12;
    currentYear--;
  }
  
  updateMonthDisplay();
  loadData();
}

function updateMonthDisplay() {
  const monthNames = [
    '', 'Th√°ng 1', 'Th√°ng 2', 'Th√°ng 3', 'Th√°ng 4', 'Th√°ng 5', 'Th√°ng 6',
    'Th√°ng 7', 'Th√°ng 8', 'Th√°ng 9', 'Th√°ng 10', 'Th√°ng 11', 'Th√°ng 12'
  ];
  
  document.getElementById('currentMonthDisplay').textContent = 
    `${monthNames[currentMonth]} ${currentYear}`;
}

function loadCurrentMonth() {
  const now = new Date();
  currentMonth = now.getMonth() + 1;
  currentYear = now.getFullYear();
  updateMonthDisplay();
  loadData();
}

// Circuit breaker pattern for API calls - T·ªëi ∆∞u h√≥a
let failureCount = 0;
let lastFailureTime = 0;
const CIRCUIT_BREAKER_THRESHOLD = 5; // TƒÉng t·ª´ 3 l√™n 5
const CIRCUIT_BREAKER_TIMEOUT = 30000; // Gi·∫£m t·ª´ 60s xu·ªëng 30s

function isCircuitBreakerOpen() {
  if (failureCount >= CIRCUIT_BREAKER_THRESHOLD) {
    const timeSinceLastFailure = Date.now() - lastFailureTime;
    if (timeSinceLastFailure < CIRCUIT_BREAKER_TIMEOUT) {
      return true;
    } else {
      // Reset circuit breaker after timeout
      failureCount = 0;
    }
  }
  return false;
}

function recordFailure() {
  failureCount++;
  lastFailureTime = Date.now();
}

function recordSuccess() {
  failureCount = 0;
}

function loadData() {
  console.log('loadData called');
  
  // Prevent multiple simultaneous loads
  if (isLoading) {
    console.log('‚è≥ Already loading, skipping duplicate request');
    return;
  }
  
  // Check cache first ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô
  const cacheKey = `${currentMonth}_${currentYear}_${searchCompany}_${filterEmployee}_${shiftFilter}_${timeFilter}_${showGold}`;
  const now = Date.now();
  
  if (dataCache[cacheKey] && (now - lastLoadTime) < CACHE_DURATION) {
    console.log('üì¶ Using cached data');
    // Hi·ªÉn th·ªã th√¥ng b√°o ng·∫Øn v·ªÅ vi·ªác s·ª≠ d·ª•ng cache
    showQuickMessage('ƒêang s·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ l∆∞u...');
    setTimeout(() => {
      onDataLoaded(dataCache[cacheKey]);
    }, 100);
    return;
  }
  
  // Check circuit breaker
  if (isCircuitBreakerOpen()) {
    showError('H·ªá th·ªëng t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau 30 gi√¢y.');
    return;
  }
  
  isLoading = true;
  pendingRequests++;
  showLoading();
  
  // TƒÉng timeout cho d·ªØ li·ªáu l·ªõn
  const timeoutId = setTimeout(() => {
    console.warn('‚ö†Ô∏è API call timeout after 20 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('T·∫£i d·ªØ li·ªáu qu√° l√¢u. Vui l√≤ng th·ª≠ l·∫°i.');
    
    // Kh√¥ng auto retry ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ t·∫≠n
    // Ng∆∞·ªùi d√πng s·∫Ω ph·∫£i click th·ª≠ l·∫°i th·ªß c√¥ng
  }, 20000); // TƒÉng l√™n 20s cho d·ªØ li·ªáu l·ªõn
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(timeoutId);
      isLoading = false;
      recordSuccess();
      
      // Cache d·ªØ li·ªáu ƒë·ªÉ s·ª≠ d·ª•ng l·∫ßn sau
      dataCache[cacheKey] = data;
      lastLoadTime = now;
      
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(timeoutId);
      isLoading = false;
      recordFailure();
      console.error('‚ùå First attempt failed:', error);
      
      // Retry nhanh h∆°n cho network errors
      if (error.message && error.message.includes('network')) {
        setTimeout(() => {
          console.log('üîÑ Network retry...');
          retryLoadData();
        }, 500);
      } else {
        // Exponential backoff v·ªõi delay ng·∫Øn h∆°n
        const retryDelay = Math.min(1500 * Math.pow(2, failureCount - 1), 5000);
        setTimeout(() => {
          console.log('üîÑ Retrying data load...');
          retryLoadData();
        }, retryDelay);
      }
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  
  // Load clinical data v·ªõi delay ng·∫Øn h∆°n
  setTimeout(() => {
    console.log('Calling loadClinicalData...');
    loadClinicalData();
  }, 200);
}

function retryLoadData() {
  // Prevent infinite retry loops
  if (failureCount >= CIRCUIT_BREAKER_THRESHOLD) {
    hideLoading();
    showError('H·ªá th·ªëng t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng th·ª≠ l·∫°i sau.');
    return;
  }
  
  // Timeout cho retry attempts
  const retryTimeoutId = setTimeout(() => {
    console.warn('‚ö†Ô∏è Retry timeout after 15 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i th·ªß c√¥ng.');
  }, 15000); // TƒÉng timeout cho retry
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(retryTimeoutId);
      isLoading = false;
      recordSuccess();
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(retryTimeoutId);
      isLoading = false;
      recordFailure();
      onDataError(error);
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
}

// T·ªëi ∆∞u h√≥a loadDataWithCurrentFilters v·ªõi smart caching
function loadDataWithCurrentFilters() {
  // Prevent multiple simultaneous requests
  if (isLoading) {
    console.log('‚è≥ Filter request already in progress');
    return;
  }
  
  // Ki·ªÉm tra cache tr∆∞·ªõc khi g·ªçi server
  const cacheKey = `${currentMonth}_${currentYear}_${searchCompany}_${filterEmployee}_${shiftFilter}_${timeFilter}_${showGold}`;
  const now = Date.now();
  
  if (dataCache[cacheKey] && (now - lastLoadTime) < CACHE_DURATION) {
    console.log('üì¶ S·ª≠ d·ª•ng d·ªØ li·ªáu t·ª´ cache cho filter');
    showQuickMessage('√Åp d·ª•ng b·ªô l·ªçc t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u...');
    setTimeout(() => {
      onDataLoaded(dataCache[cacheKey]);
    }, 50);
    return;
  }
  
  isLoading = true;
  showLoading();
  
  // Timeout cho filter loading
  const filterTimeoutId = setTimeout(() => {
    console.warn('‚ö†Ô∏è Filter loading timeout after 15 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('T·∫£i d·ªØ li·ªáu l·ªçc qu√° l√¢u. Vui l√≤ng th·ª≠ l·∫°i th·ªß c√¥ng.');
    
    // Kh√¥ng auto retry ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ t·∫≠n
  }, 15000); // TƒÉng timeout l√™n 15s
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(filterTimeoutId);
      isLoading = false;
      
      // Cache d·ªØ li·ªáu ƒë·ªÉ s·ª≠ d·ª•ng l·∫ßn sau
      dataCache[cacheKey] = data;
      lastLoadTime = now;
      
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(filterTimeoutId);
      isLoading = false;
      onDataError(error);
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  
  // Load clinical data v·ªõi delay ng·∫Øn h∆°n
  setTimeout(() => {
    loadClinicalData();
  }, 300);
}

function refreshData() {
  // Clear cache ƒë·ªÉ force reload
  dataCache = {};
  lastLoadTime = 0;
  isLoading = false;
  pendingRequests = 0;
  
  showLoading();
  
  // Reset all filters
  searchCompany = '';
  filterEmployee = '';
  showGold = false;
  shiftFilter = 'total';
  timeFilter = 'all';
  document.getElementById('companySearch').value = '';
  document.getElementById('employeeFilter').value = '';
  document.getElementById('showGold').checked = false;
  document.getElementById('shiftFilter').value = 'total';
  document.getElementById('timeFilter').value = 'all';
  
  google.script.run
    .withSuccessHandler(onRefreshDataLoaded)
    .withFailureHandler(onDataError)
    .refreshCache();
}

function onDataLoaded(data) {
  console.log('‚úÖ Data loaded successfully');
  pendingRequests = Math.max(0, pendingRequests - 1);
  
  if (!data.success) {
    hideLoading();
    showError(data.error || 'C√≥ l·ªói x·∫£y ra khi t·∫£i d·ªØ li·ªáu');
    return;
  }
  
  console.log('üìä Data loaded with shiftFilter:', data.summary?.shiftFilter || 'unknown');
  console.log('üìä Data loaded with timeFilter:', data.summary?.timeFilter || 'all');
  
  // Cache data for faster subsequent loads
  originalData = JSON.parse(JSON.stringify(data)); // Deep clone
  dashboardData = data;
  
  // T·ªëi ∆∞u h√≥a progressive rendering v·ªõi requestAnimationFrame
  try {
    // Step 1: ·∫®n loading ngay l·∫≠p t·ª©c ƒë·ªÉ c·∫£i thi·ªán UX
    hideLoading();
    
    // Step 2: Show dashboard structure
    showDashboard();
    
    // Step 3: Update filters (fast operation)
    updateEmployeeFilter(data.employees || []);
    
    // Step 4: Render content v·ªõi requestAnimationFrame ƒë·ªÉ smooth h∆°n
    requestAnimationFrame(() => {
      renderDashboard(dashboardData);
      
      // Step 5: Update charts sau khi render xong
      requestAnimationFrame(() => {
        updateCharts();
      });
    });
    
  } catch (error) {
    console.error('‚ùå Error rendering dashboard:', error);
    hideLoading();
    showError('C√≥ l·ªói khi hi·ªÉn th·ªã d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.');
  }
}

function onRefreshDataLoaded(data) {
  onDataLoaded(data);
}

function onDataError(error) {
  hideLoading();
  showError(error.message || 'Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.');
  console.error('Error:', error);
}

function updateEmployeeFilter(employees) {
  const select = document.getElementById('employeeFilter');
  
  // Keep current selection
  const currentValue = select.value;
  
  // Clear existing options except first
  select.innerHTML = '<option value="">T·∫•t c·∫£ nh√¢n vi√™n</option>';
  
  // Add employee options
  employees.forEach(employee => {
    const option = document.createElement('option');
    option.value = employee;
    option.textContent = employee;
    select.appendChild(option);
  });
  
  // Restore selection if still valid
  if (currentValue && employees.includes(currentValue)) {
    select.value = currentValue;
  }
}

// Filter function ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a l·∫°i ·ªü cu·ªëi file

function onFilterDataLoaded(data) {
  hideLoading();
  
  if (!data.success) {
    showError(data.error || 'C√≥ l·ªói x·∫£y ra khi t·∫£i d·ªØ li·ªáu');
    return;
  }
  
  console.log('üîÑ Filtered data loaded with shiftFilter:', data.summary?.shiftFilter || 'unknown');
  console.log('üîÑ Filtered data loaded with timeFilter:', data.summary?.timeFilter || 'all');
  
  // C·∫≠p nh·∫≠t data hi·ªán t·∫°i
  dashboardData = data;
  
  renderDashboard(dashboardData);
  showDashboard();
  
  // Update charts
  updateCharts();
}

// Calculate statistics based on actual filtered data from server
function renderStats(summary) {
  // S·ª≠ d·ª•ng data t·ª´ server thay v√¨ t√≠nh to√°n l·∫°i client-side
  document.getElementById('totalCompanies').textContent = formatNumber(summary.totalCompanies || 0);
  document.getElementById('completedCompanies').textContent = formatNumber(summary.completedCompanies || 0);
  document.getElementById('activeCompanies').textContent = formatNumber(summary.activeCompanies || 0);
  document.getElementById('averagePerDay').textContent = formatNumber(summary.averagePerDay || 0);
  
  console.log('üìä Stats rendered:', {
    total: summary.totalCompanies,
    completed: summary.completedCompanies,
    active: summary.activeCompanies,
    avg: summary.averagePerDay,
    filter: summary.shiftFilter,
    timeFilter: summary.timeFilter
  });
}

function formatNumber(num) {
  return new Intl.NumberFormat('vi-VN').format(num);
}

/**
 * Enhanced company name shortening - c·ªë ƒë·ªãnh cho 300px
 */
function shortenCompanyName(fullName) {
  const shortcuts = {
    'C√îNG TY C·ªî PH·∫¶N': 'CP',
    'C√îNG TY TNHH': 'TNHH',
    'CHI NH√ÅNH C√îNG TY': 'CN',
    'C√îNG TY CP': 'CP',
    'XU·∫§T NH·∫¨P KH·∫®U': 'XNK',
    'TH∆Ø∆†NG M·∫†I': 'TM',
    'D·ªäCH V·ª§': 'DV',
    'KINH DOANH': 'KD',
    'PH√ÅT TRI·ªÇN': 'PT',
    'ƒê·∫¶U T∆Ø': 'ƒêT',
    'S·∫¢N XU·∫§T': 'SX',
    'LOGISTICS': 'LOG',
    'INTERNATIONAL': 'INTL',
    'DEVELOPMENT': 'DEV',
    'TECHNOLOGY': 'TECH',
    'SOLUTIONS': 'SOL',
    'EDUCATION': 'EDU',
    'SOFTWARE': 'SW'
  };
  
  let shortened = fullName;
  
  // Apply shortcuts
  Object.keys(shortcuts).forEach(key => {
    const regex = new RegExp(key, 'gi');
    shortened = shortened.replace(regex, shortcuts[key]);
  });
  
  // Fixed max length for 300px column
  const maxLength = 35;
  if (shortened.length > maxLength) {
    shortened = shortened.substring(0, maxLength - 3) + '...';
  }
  
  return shortened;
}

function createTooltip(companyName, date, peopleCount) {
  return `${companyName}\nNg√†y ${date}: ${peopleCount} ng∆∞·ªùi kh√°m`;
}

function renderDashboard(data) {
  renderStats(data.summary);
  renderTimeline(data.timeline);
}

function renderTimeline(timeline) {
  if (!timeline.dates || timeline.dates.length === 0) {
    document.getElementById('timelineBody').innerHTML = 
      '<tr><td colspan="100%" style="text-align: center; padding: 20px; color: #64748b;">Kh√¥ng c√≥ d·ªØ li·ªáu</td></tr>';
    return;
  }
  
  // Clear existing content
  const weekdayRow = document.getElementById('weekdayRow');
  const dateRow = document.getElementById('dateRow');
  const tbody = document.getElementById('timelineBody');
  
  // Reset headers - keep fixed columns
  weekdayRow.innerHTML = `
    <th class="company-header"></th>
    <th class="people-header"></th>
  `;
  dateRow.innerHTML = `
    <th class="company-header">C√¥ng ty</th>
    <th class="people-header">Ng∆∞·ªùi</th>
  `;
  tbody.innerHTML = '';
  
  const today = new Date();
  const isCurrentMonth = (currentMonth === today.getMonth() + 1) && (currentYear === today.getFullYear());
  const todayDate = today.getDate();
  
  // Create weekday and date headers
  timeline.dates.forEach((date, index) => {
    const weekday = timeline.weekdays[index];
    
    // Weekday header
    const weekdayTh = document.createElement('th');
    weekdayTh.textContent = weekday;
    weekdayTh.classList.add('weekday-header');
    
    // Date header
    const dateTh = document.createElement('th');
    dateTh.textContent = date;
    dateTh.classList.add('date-header');
    
    // Mark weekends
    if (weekday === 'CN' || weekday === 'T7') {
      weekdayTh.classList.add('weekend');
      dateTh.classList.add('weekend');
    }
    
    // Mark today - only headers
    if (isCurrentMonth && date === todayDate) {
      weekdayTh.classList.add('today');
      dateTh.classList.add('today');
    }
    
    weekdayRow.appendChild(weekdayTh);
    dateRow.appendChild(dateTh);
  });
  
  // S·∫Øp x·∫øp c√°c h√†ng: c√¥ng ty ch∆∞a kh√°m xong tr∆∞·ªõc (theo s·ªë ng∆∞·ªùi gi·∫£m d·∫ßn), c√¥ng ty ƒë√£ kh√°m xong sau (theo s·ªë ng∆∞·ªùi gi·∫£m d·∫ßn)
  timeline.rows.sort((a, b) => {
    // L·∫•y th√¥ng tin tr·∫°ng th√°i c√¥ng ty t·ª´ timeline row v√† chu·∫©n h√≥a
    const statusA = (a.trangThai || '').toLowerCase().trim();
    const statusB = (b.trangThai || '').toLowerCase().trim();
    
    const isCompletedA = statusA === 'ƒë√£ kh√°m xong' || statusA === 'da kham xong';
    const isCompletedB = statusB === 'ƒë√£ kh√°m xong' || statusB === 'da kham xong';
    
    // N·∫øu m·ªôt c√¥ng ty ƒë√£ kh√°m xong v√† m·ªôt c√¥ng ty ch∆∞a kh√°m xong
    if (isCompletedA !== isCompletedB) {
      return isCompletedA ? 1 : -1; // Ch∆∞a kh√°m xong (false) l√™n tr∆∞·ªõc
    }
    
    // N·∫øu c·∫£ hai c√πng tr·∫°ng th√°i, s·∫Øp x·∫øp theo s·ªë ng∆∞·ªùi gi·∫£m d·∫ßn
    return b.total - a.total;
  });
  
  // Calculate daily totals for the currently displayed companies
  const dailyTotalsFiltered = new Array(timeline.dates.length).fill(0);
  timeline.rows.forEach(row => {
    row.data.forEach((value, index) => {
      dailyTotalsFiltered[index] += value;
    });
  });

  // Add total row first
  const totalTr = document.createElement('tr');
  totalTr.classList.add('total-row', 'clickable');

  const totalCompanyCell = document.createElement('td');
  totalCompanyCell.classList.add('company-cell');
  totalCompanyCell.textContent = 'T·ªîNG';
  
  // Add click event for total details
  totalCompanyCell.addEventListener('click', () => {
    showTotalDetail();
  });
  
  totalTr.appendChild(totalCompanyCell);

  const totalPeopleCell = document.createElement('td');
  totalPeopleCell.classList.add('people-cell');
  const grandTotal = dailyTotalsFiltered.reduce((sum, val) => sum + val, 0);
  totalPeopleCell.textContent = formatNumber(grandTotal);
  totalTr.appendChild(totalPeopleCell);

  dailyTotalsFiltered.forEach((total, dayIndex) => {
    const td = document.createElement('td');
    td.classList.add('data-cell');
    const inner = document.createElement('div');
    inner.classList.add('data-cell-inner');
    inner.textContent = total > 0 ? total : '';
    if (total > 0) {
      td.classList.add('has-data');
      if (total > 100) {
        td.classList.add('high-volume');
      }
      
      // Th√™m s·ª± ki·ªán click cho √¥ d·ªØ li·ªáu trong h√†ng t·ªïng
      td.addEventListener('click', () => {
        showDailyTotalDetail(timeline.dates[dayIndex], dayIndex);
      });
      td.classList.add('clickable');
    } else {
      td.classList.add('empty');
    }
    // Mark weekends for total row
    const weekday = timeline.weekdays[dayIndex];  
    if (weekday === 'CN' || weekday === 'T7') {
      td.classList.add('weekend');
    }
    
    // Mark today column for total row
    const timelineDate = timeline.dates[dayIndex];
    if (isCurrentMonth && timelineDate === todayDate) {
      td.classList.add('today-column');
    }
    
    td.appendChild(inner);
    totalTr.appendChild(td);
  });
  tbody.appendChild(totalTr);
  
  // Create data rows
  timeline.rows.forEach(row => {
    const tr = document.createElement('tr');
    
    // Company name cell
    const companyCell = document.createElement('td');
    companyCell.classList.add('company-cell', 'clickable');
    const displayName = shortenCompanyName(row.company);
    companyCell.textContent = displayName;
    companyCell.title = row.company; // Full name on hover
    
    // Ki·ªÉm tra n·∫øu c√¥ng ty ƒë√£ kh√°m xong th√¨ ƒë·ªïi m√†u ch·ªØ th√†nh xanh l√° c√¢y
    const status = (row.trangThai || '').toLowerCase().trim();
    const isCompleted = status === 'ƒë√£ kh√°m xong' || status === 'da kham xong';
    if (isCompleted) {
      companyCell.style.color = '#007bff'; // M√†u xanh l√° c√¢y
      companyCell.style.fontWeight = 'bold';
    }
    
    // Add click event for company details
    companyCell.addEventListener('click', () => {
      showCompanyDetail(row.company);
    });
    
    tr.appendChild(companyCell);
    
    // People count cell - Hi·ªÉn th·ªã t·ªïng s·ªë ng∆∞·ªùi trong c·∫£ giai ƒëo·∫°n
    const peopleCell = document.createElement('td');
    peopleCell.classList.add('people-cell');
    
    // L·∫•y th√¥ng tin chi ti·∫øt c√¥ng ty ƒë·ªÉ t√≠nh t·ªïng s·ªë ng∆∞·ªùi ƒë√∫ng
    let totalPeopleForCompany = 0;
    if (dashboardData && dashboardData.companyDetails && dashboardData.companyDetails[row.company]) {
      const companyDetail = dashboardData.companyDetails[row.company];
      totalPeopleForCompany = companyDetail.tongNguoi || 0;
    } else {
      // Fallback: s·ª≠ d·ª•ng row.total n·∫øu kh√¥ng c√≥ companyDetails
      totalPeopleForCompany = row.total || 0;
    }
    
    if (totalPeopleForCompany > 0) {
      peopleCell.textContent = formatNumber(totalPeopleForCompany);
    } else {
      peopleCell.textContent = '0';
    }
    tr.appendChild(peopleCell);
    
    // Data cells - Rounded design
    row.data.forEach((value, dayIndex) => {
      const td = document.createElement('td');
      td.classList.add('data-cell');
      
      const inner = document.createElement('div');
      inner.classList.add('data-cell-inner');
      
      // Ki·ªÉm tra ng√†y l·∫•y m√°u tr∆∞·ªõc khi x·ª≠ l√Ω d·ªØ li·ªáu kh√°m
      const currentDay = timeline.dates[dayIndex];
      const currentDate = `${currentMonth}/${currentDay.toString().padStart(2, '0')}/${currentYear}`;
      let isBloodDate = false;
      
      if (row.ngayLayMau && typeof row.ngayLayMau === 'string') {
        // Chu·∫©n h√≥a ƒë·ªãnh d·∫°ng ng√†y ƒë·ªÉ so s√°nh
        const normalizedBloodDate = normalizeDate(row.ngayLayMau);
        const normalizedCurrentDate = normalizeDate(currentDate);
        const normalizedStartDate = normalizeDate(row.ngayBatDau);
        const normalizedEndDate = normalizeDate(row.ngayKetThuc);
        
        // Ki·ªÉm tra n·∫øu ng√†y l·∫•y m√°u tr√πng v·ªõi ng√†y hi·ªán t·∫°i
        if (normalizedBloodDate === normalizedCurrentDate) {
          isBloodDate = true;
          // √Åp d·ª•ng m√†u v√†ng cho ng√†y l·∫•y m√°u
          inner.style.backgroundColor = '#fdffb6';
          inner.style.color = '#2d6633';
          
          // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu kh√°m nh∆∞ng l√† ng√†y l·∫•y m√°u, ch·ªâ hi·ªÉn th·ªã m√†u n·ªÅn
          if (value === 0) {
            // Ki·ªÉm tra n·∫øu ng√†y l·∫•y m√°u kh√°c ng√†y b·∫Øt ƒë·∫ßu th√¨ hi·ªÉn th·ªã icon ü©∏
            if (normalizedBloodDate !== normalizedStartDate) {
              inner.textContent = '.'; // Th√™m icon m√°u
            } else {
              inner.textContent = ''; // Ng√†y b·∫Øt ƒë·∫ßu kh√¥ng c√≥ icon
            }
            inner.style.fontSize = '10px';
            inner.style.fontWeight = 'normal';
            td.classList.add('blood-date-only');
            td.title = `${row.company}\nNg√†y l·∫•y m√°u: ${formatDate(row.ngayLayMau)}`;
          }
        }
      }
      
      if (value > 0) {
        inner.textContent = value;
        td.classList.add('has-data');
        
        // Highlight high volume (>100 people)
        if (value > 100) {
          td.classList.add('high-volume');
        }
        
        // Add tooltip
        let tooltipText = createTooltip(row.company, timeline.dates[dayIndex], value);
        if (isBloodDate) {
          tooltipText += `\nNg√†y l·∫•y m√°u: ${formatDate(row.ngayLayMau)}`;
        }
        td.title = tooltipText;
        
      } else if (!isBloodDate) {
        inner.textContent = '';
        td.classList.add('empty');
      }
      
      // Mark weekends
      const weekday = timeline.weekdays[dayIndex];
      if (weekday === 'CN' || weekday === 'T7') {
        td.classList.add('weekend');
      }
      
      // Mark today column for data rows
      const timelineDate = timeline.dates[dayIndex];
      if (isCurrentMonth && timelineDate === todayDate) {
        td.classList.add('today-column');
      }
      
      td.appendChild(inner);
      tr.appendChild(td);
    });
    
    tbody.appendChild(tr);
  });
}

// H√†m ƒë·ªãnh d·∫°ng ng√†y th√°ng nƒÉm theo mm/dd/yyyy (Google Sheets format)
function formatDate(dateString) {
  if (!dateString) return '';
  
  // Ki·ªÉm tra n·∫øu dateString ƒë√£ l√† ƒë·ªãnh d·∫°ng mm/dd/yyyy
  if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
    return dateString;
  }
  
  // N·∫øu l√† ƒë·ªãnh d·∫°ng ISO ho·∫∑c kh√°c
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString; // Tr·∫£ v·ªÅ nguy√™n b·∫£n n·∫øu kh√¥ng ph·∫£i ng√†y h·ª£p l·ªá
    
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    
    return `${month}/${day}/${year}`;
  } catch (e) {
    console.error('L·ªói ƒë·ªãnh d·∫°ng ng√†y:', e);
    return dateString;
  }
}

// H√†m chu·∫©n h√≥a ƒë·ªãnh d·∫°ng ng√†y ƒë·ªÉ so s√°nh
function normalizeDate(dateString) {
  if (!dateString) return '';
  
  try {
    // X·ª≠ l√Ω c√°c ƒë·ªãnh d·∫°ng kh√°c nhau
    let normalizedDate = dateString.toString().trim();
    
    // N·∫øu l√† ƒë·ªãnh d·∫°ng mm/dd/yyyy
    if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(normalizedDate)) {
      const parts = normalizedDate.split('/');
      const month = parts[0].padStart(2, '0');
      const day = parts[1].padStart(2, '0');
      const year = parts[2];
      return `${month}/${day}/${year}`;
    }
    
    // N·∫øu l√† ƒë·ªãnh d·∫°ng dd/mm/yyyy ho·∫∑c yyyy-mm-dd
    const date = new Date(normalizedDate);
    if (!isNaN(date.getTime())) {
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${month}/${day}/${year}`;
    }
    
    return normalizedDate;
  } catch (e) {
    console.error('L·ªói chu·∫©n h√≥a ng√†y:', e);
    return dateString;
  }
}

// H√†m ki·ªÉm tra ng√†y c√≥ n·∫±m ngo√†i kho·∫£ng kh√°m kh√¥ng
function isDateOutsideRange(bloodDate, startDate, endDate) {
  if (!bloodDate || !startDate || !endDate) return false;
  
  try {
    const blood = new Date(bloodDate);
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    return blood < start || blood > end;
  } catch (e) {
    console.error('L·ªói so s√°nh ng√†y:', e);
    return false;
  }
}

// Modal functions
function showCompanyDetail(companyName) {
  if (!dashboardData || !dashboardData.companyDetails) {
    console.log('Kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt c√¥ng ty');
    return;
  }
  
  const companyDetail = dashboardData.companyDetails[companyName];
  if (!companyDetail) {
    console.log('Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt cho c√¥ng ty:', companyName);
    return;
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Th√™m th√¥ng tin filter v√†o title
  let titleText = companyName;
  if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    titleText += ' (Ca s√°ng)';
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    titleText += ' (Ca chi·ªÅu)';
  }
  
  // T√≠nh t·ªïng s·ªë l∆∞·ª£ng kh√°m s√°ng/chi·ªÅu d·ª±a tr√™n shiftFilter hi·ªán t·∫°i
  let displayMorning = 0;
  let displayAfternoon = 0;
  let displayTotal = 0;
  
  // L·∫•y t·ªïng s·ªë ng√†y kh√°m
  const totalDays = companyDetail.tongSoNgay || 0;
  
  if (shiftFilter === 'total') {
    // Hi·ªÉn th·ªã t·ªïng s·ªë l∆∞·ª£ng kh√°m chia ƒë·ªÅu 50/50
    displayTotal = companyDetail.tongNguoi || 0;
    displayMorning = Math.round(displayTotal / 2);
    displayAfternoon = displayTotal - displayMorning; // ƒê·∫£m b·∫£o t·ªïng b·∫±ng displayTotal
  } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    // Ch·ªâ hi·ªÉn th·ªã t·ªïng ca s√°ng, ca chi·ªÅu = 0
    displayMorning = (companyDetail.sang || 0) * totalDays;
    displayAfternoon = 0;
    displayTotal = displayMorning;
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    // Ch·ªâ hi·ªÉn th·ªã t·ªïng ca chi·ªÅu, ca s√°ng = 0
    displayMorning = 0;
    displayAfternoon = (companyDetail.chieu || 0) * totalDays;
    displayTotal = displayAfternoon;
  }
  
  // ƒê·ªãnh d·∫°ng ng√†y b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c kh√°m
  const startDate = companyDetail.ngayBatDau || '';
  const endDate = companyDetail.ngayKetThuc || '';
  const dateRangeText = startDate && endDate ? `${startDate} - ${endDate}` : 'Ch∆∞a c√≥ th√¥ng tin';
  
  // üîß FIX: Apply formatNumber cho t·∫•t c·∫£ s·ªë li·ªáu
  modalBody.innerHTML = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">S·ªë l∆∞·ª£ng kh√°m s√°ng:</span>
      <span class="detail-value">${formatNumber(displayMorning)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">S·ªë l∆∞·ª£ng kh√°m chi·ªÅu:</span>
      <span class="detail-value">${formatNumber(displayAfternoon)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë ng∆∞·ªùi kh√°m:</span>
      <span class="detail-value">${formatNumber(displayTotal)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë ng√†y kh√°m:</span>
      <span class="detail-value">${formatNumber(companyDetail.tongSoNgay || 0)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Kho·∫£ng th·ªùi gian kh√°m:</span>
      <span class="detail-value">${dateRangeText}</span>
    </div>
    ${companyDetail.employee ? `
    <div class="detail-row">
      <span class="detail-label">Nh√¢n vi√™n ph·ª• tr√°ch:</span>
      <span class="detail-value">${companyDetail.employee}</span>
    </div>
    ` : ''}
    ${companyDetail.ngayLayMau ? `
    <div class="detail-row">
      <span class="detail-label">Ng√†y l·∫•y m√°u:</span>
      <span class="detail-value">${formatDate(companyDetail.ngayLayMau)}</span>
    </div>
    ` : ''}
  `;
  
  modal.classList.add('show');
}

function showTotalDetail() {
  if (!dashboardData || !dashboardData.companyDetails) {
    console.log('Kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt');
    return;
  }
  
  // T√≠nh t·ªïng d·ª±a tr√™n companies ƒëang hi·ªÉn th·ªã v√† current shiftFilter
  let totalSang = 0;
  let totalChieu = 0;
  let totalNguoi = 0;
  
  // L·ªçc theo c√¥ng ty ƒëang hi·ªÉn th·ªã trong dashboardData
  if (dashboardData && dashboardData.timeline && dashboardData.timeline.rows) {
    dashboardData.timeline.rows.forEach(row => {
      if (row.company && row.company !== 'T·ªîNG' && !row.isSpacing) {
        const companyDetail = dashboardData.companyDetails[row.company];
        if (companyDetail) {
          // L·∫•y t·ªïng s·ªë ng√†y kh√°m c·ªßa c√¥ng ty
          const totalDays = companyDetail.tongSoNgay || 0;
          
          // T√≠nh to√°n t·ªïng s·ªë l∆∞·ª£ng kh√°m d·ª±a tr√™n shiftFilter hi·ªán t·∫°i
          if (shiftFilter === 'total') {
            // Ch·ªâ c·ªông d·ªìn t·ªïng s·ªë ng∆∞·ªùi kh√°m, sau ƒë√≥ s·∫Ω chia ƒë·ªÅu ·ªü b√™n d∆∞·ªõi
            totalNguoi += companyDetail.tongNguoi || 0;
          } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
            totalSang += (companyDetail.sang || 0) * totalDays;
            totalChieu = 0; // Kh√¥ng hi·ªÉn th·ªã ca chi·ªÅu khi filter ca s√°ng
            totalNguoi += (companyDetail.sang || 0) * totalDays;
          } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
            totalSang = 0; // Kh√¥ng hi·ªÉn th·ªã ca s√°ng khi filter ca chi·ªÅu
            totalChieu += (companyDetail.chieu || 0) * totalDays;
            totalNguoi += (companyDetail.chieu || 0) * totalDays;
          }
        }
      }
    });
  }
  
  // N·∫øu ƒëang xem t·ªïng (kh√¥ng filter), chia ƒë·ªÅu t·ªïng s·ªë ng∆∞·ªùi kh√°m th√†nh hai ph·∫ßn b·∫±ng nhau
  if (shiftFilter === 'total') {
    totalSang = Math.round(totalNguoi / 2);
    totalChieu = totalNguoi - totalSang; // ƒê·∫£m b·∫£o t·ªïng b·∫±ng totalNguoi
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Display title theo current filter
  let titleText = 'T·ªïng h·ª£p t·∫•t c·∫£ c√¥ng ty';
  if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    titleText += ' (Ca s√°ng)';
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    titleText += ' (Ca chi·ªÅu)';
  }
  
  // Th√™m th√¥ng tin v·ªÅ time filter
  if (timeFilter !== 'all') {
    const timeFilterText = timeFilter === 'today' ? 'H√¥m nay' : 
                          timeFilter === 'week' ? 'Tu·∫ßn n√†y' : 
                          timeFilter === 'month' ? 'Th√°ng n√†y' : '';
    if (timeFilterText) {
      titleText += ` - ${timeFilterText}`;
    }
  }
  
  // üîß FIX: Apply formatNumber cho t·∫•t c·∫£ s·ªë li·ªáu
  modalBody.innerHTML = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë l∆∞·ª£ng kh√°m s√°ng:</span>
      <span class="detail-value">${formatNumber(totalSang)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë l∆∞·ª£ng kh√°m chi·ªÅu:</span>
      <span class="detail-value">${formatNumber(totalChieu)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë ng∆∞·ªùi kh√°m:</span>
      <span class="detail-value">${formatNumber(totalNguoi)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Filter hi·ªán t·∫°i:</span>
      <span class="detail-value">${shiftFilter === 'total' ? 'T·ªïng' : shiftFilter === 'sang' ? 'S√°ng' : 'Chi·ªÅu'}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Th·ªùi gian hi·ªán t·∫°i:</span>
      <span class="detail-value">${timeFilter === 'all' ? 'T·∫•t c·∫£' : 
                                  timeFilter === 'today' ? 'H√¥m nay' : 
                                  timeFilter === 'week' ? 'Tu·∫ßn n√†y' : 'Th√°ng n√†y'}</span>
    </div>
  `;
  
  modal.classList.add('show');
}

/**
 * Hi·ªÉn th·ªã chi ti·∫øt cho m·ªôt ng√†y c·ª• th·ªÉ trong h√†ng t·ªïng
 */
function showDailyTotalDetail(day, dayIndex) {
  if (!dashboardData || !dashboardData.timeline || !dashboardData.companyDetails) {
    console.log('Kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt ng√†y');
    return;
  }
  
  const timeline = dashboardData.timeline;
  const month = currentMonth;
  const year = currentYear;
  const dateStr = `${day}/${month}/${year}`;
  const weekday = timeline.weekdays[dayIndex];
  
  // T√≠nh t·ªïng s·ªë ng∆∞·ªùi kh√°m trong ng√†y n√†y cho t·∫•t c·∫£ c√¥ng ty ƒëang hi·ªÉn th·ªã
  let totalPeopleToday = 0;
  let companiesWithAppointments = [];
  
  // T√≠nh s·ªë l∆∞·ª£ng kh√°m s√°ng/chi·ªÅu cho ng√†y n√†y d·ª±a tr√™n shiftFilter hi·ªán t·∫°i
  let morningExams = 0;
  let afternoonExams = 0;
  
  // L·ªçc theo c√¥ng ty ƒëang hi·ªÉn th·ªã trong dashboardData
  if (timeline && timeline.rows) {
    timeline.rows.forEach(row => {
      if (row.company && row.company !== 'T·ªîNG' && !row.isSpacing) {
        const peopleCount = row.data[dayIndex] || 0;
        
        if (peopleCount > 0) {
          totalPeopleToday += peopleCount;
          
          // T√≠nh s·ªë l∆∞·ª£ng kh√°m s√°ng/chi·ªÅu d·ª±a tr√™n shiftFilter hi·ªán t·∫°i
          if (shiftFilter === 'total') {
            // Kh√¥ng t√≠nh theo t·ª∑ l·ªá th·ª±c t·∫ø c·ªßa c√¥ng ty n·ªØa m√† chia ƒë·ªÅu 50/50
            // C·ªông d·ªìn s·ªë ng∆∞·ªùi kh√°m, sau ƒë√≥ s·∫Ω chia ƒë·ªÅu ·ªü b√™n d∆∞·ªõi
          } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
            // N·∫øu ƒëang filter ca s√°ng, t·∫•t c·∫£ s·ªë ng∆∞·ªùi ƒë·ªÅu l√† ca s√°ng
            morningExams += peopleCount;
            afternoonExams = 0;
          } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
            // N·∫øu ƒëang filter ca chi·ªÅu, t·∫•t c·∫£ s·ªë ng∆∞·ªùi ƒë·ªÅu l√† ca chi·ªÅu
            afternoonExams += peopleCount;
            morningExams = 0;
          }
          
          // Th√™m v√†o danh s√°ch c√¥ng ty c√≥ l·ªãch kh√°m
          companiesWithAppointments.push({
            name: row.company,
            people: peopleCount,
            employee: row.employee || ''
          });
        }
      }
    });
  }
  
  // S·∫Øp x·∫øp theo nh√¢n vi√™n (A->Z) tr∆∞·ªõc, sau ƒë√≥ theo s·ªë ng∆∞·ªùi kh√°m gi·∫£m d·∫ßn
  companiesWithAppointments.sort((a, b) => {
    // So s√°nh t√™n nh√¢n vi√™n tr∆∞·ªõc
    const employeeA = a.employee || '';
    const employeeB = b.employee || '';
    const employeeComparison = employeeA.localeCompare(employeeB, 'vi', { sensitivity: 'base' });
    if (employeeComparison !== 0) {
      return employeeComparison;
    }
    // N·∫øu nh√¢n vi√™n gi·ªëng nhau, s·∫Øp x·∫øp theo s·ªë ng∆∞·ªùi gi·∫£m d·∫ßn
    return b.people - a.people;
  });
  
  // N·∫øu ƒëang xem t·ªïng (kh√¥ng filter), chia ƒë·ªÅu t·ªïng s·ªë ng∆∞·ªùi kh√°m th√†nh hai ph·∫ßn b·∫±ng nhau
  if (shiftFilter === 'total') {
    morningExams = Math.round(totalPeopleToday / 2);
    afternoonExams = totalPeopleToday - morningExams; // ƒê·∫£m b·∫£o t·ªïng b·∫±ng totalPeopleToday
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Hi·ªÉn th·ªã ti√™u ƒë·ªÅ v·ªõi th√¥ng tin ng√†y
  const titleText = `Chi ti·∫øt ng√†y ${dateStr} (${weekday})`;
  
  // T·∫°o n·ªôi dung chi ti·∫øt
  let detailContent = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">T·ªïng s·ªë ng∆∞·ªùi kh√°m:</span>
      <span class="detail-value">${totalPeopleToday}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">S·ªë l∆∞·ª£ng kh√°m s√°ng:</span>
      <span class="detail-value">${morningExams}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">S·ªë l∆∞·ª£ng kh√°m chi·ªÅu:</span>
      <span class="detail-value">${afternoonExams}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">S·ªë c√¥ng ty c√≥ l·ªãch kh√°m:</span>
      <span class="detail-value">${companiesWithAppointments.length}</span>
    </div>
  `;
  
  // Th√™m danh s√°ch c√¥ng ty c√≥ l·ªãch kh√°m
  if (companiesWithAppointments.length > 0) {
    detailContent += `
      <div class="detail-section">
        <h4 class="detail-section-title">Danh s√°ch c√¥ng ty c√≥ l·ªãch kh√°m:</h4>
        <div class="company-list">
    `;
    
    companiesWithAppointments.forEach(company => {
      detailContent += `
        <div class="company-list-item">
          <span class="company-name">${company.name}</span>
          <span class="company-people">${company.people} ng∆∞·ªùi</span>
          ${company.employee ? `<span class="company-employee">NV: ${getShortName(company.employee)}</span>` : ''}
        </div>
      `;
    });
    
    detailContent += `
        </div>
      </div>
    `;
  }
  
  modalBody.innerHTML = detailContent;
  modal.classList.add('show');
}

function closeDetailModal() {
  const modal = document.getElementById('detailModal');
  modal.classList.remove('show');
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
  const modal = document.getElementById('detailModal');
  if (event.target === modal) {
    closeDetailModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    closeDetailModal();
  }
});

// Helper function to get short name (only last name)
function getShortName(fullName) {
  if (!fullName) return '';
  const nameParts = fullName.trim().split(' ');
  return nameParts[nameParts.length - 1]; // L·∫•y t·ª´ cu·ªëi c√πng
}

// UI State Management
function showLoading() {
  document.getElementById('loading').style.display = 'flex';
  document.getElementById('error').style.display = 'none';
  document.getElementById('dashboard').style.display = 'none';
}

function hideLoading() {
  document.getElementById('loading').style.display = 'none';
}

function showError(message) {
  document.getElementById('errorMessage').textContent = message;
  document.getElementById('error').style.display = 'block';
  document.getElementById('dashboard').style.display = 'none';
}

// H√†m hi·ªÉn th·ªã th√¥ng b√°o nhanh cho cache
function showQuickMessage(message) {
  const loadingDiv = document.getElementById('loading');
  const loadingText = loadingDiv.querySelector('div');
  if (loadingText) {
    const originalText = loadingText.textContent;
    loadingText.textContent = message;
    loadingDiv.style.display = 'flex';
    
    // Hide after short delay
    setTimeout(() => {
      loadingDiv.style.display = 'none';
      loadingText.textContent = originalText;
    }, 800);
  }
}

function showDashboard() {
  document.getElementById('error').style.display = 'none';
  document.getElementById('dashboard').style.display = 'block';
}

// Enhanced keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    switch(e.key) {
      case 'r':
        e.preventDefault();
        refreshData();
        break;
      case 'ArrowLeft':
        e.preventDefault();
        navigateMonth(-1);
        break;
      case 'ArrowRight':
        e.preventDefault();
        navigateMonth(1);
        break;
      case 'f':
        e.preventDefault();
        // Removed showCompleted functionality
        break;
      case 'k':
        e.preventDefault();
        document.getElementById('companySearch').focus();
        break;
    }
  }
});

// Error handling
window.addEventListener('error', (e) => {
  console.error('JavaScript error:', e.error);
  if (document.getElementById('loading').style.display !== 'none') {
    showError('C√≥ l·ªói x·∫£y ra. Vui l√≤ng t·∫£i l·∫°i trang.');
  }
});

// Smart auto-refresh with user activity detection
let lastUserActivity = Date.now();
let autoRefreshEnabled = true;

// Track user activity
['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
  document.addEventListener(event, () => {
    lastUserActivity = Date.now();
  }, { passive: true });
});

// Auto-refresh only when user is inactive for 2+ minutes
setInterval(() => {
  const timeSinceActivity = Date.now() - lastUserActivity;
  const isUserIdle = timeSinceActivity > 2 * 60 * 1000; // 2 minutes
  
  if (autoRefreshEnabled && 
      isUserIdle && 
      document.getElementById('dashboard').style.display === 'block' &&
      !isCircuitBreakerOpen()) {
    console.log('üîÑ Auto-refreshing data (user idle)');
    loadData();
  }
}, 5 * 60 * 1000); // Check every 5 minutes

// Allow users to disable auto-refresh
function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  console.log('Auto-refresh:', autoRefreshEnabled ? 'enabled' : 'disabled');
}

// Clinical Examination Table Functions
function loadClinicalData() {
  console.log('loadClinicalData called with params:', {
    currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold
  });
  
  // Don't show loading for clinical data to avoid blocking main UI
  // showLoading();
  
  // Add timeout for clinical data
  const clinicalTimeoutId = setTimeout(() => {
    console.warn('‚ö†Ô∏è Clinical data timeout after 8 seconds');
    // Don't show error for clinical data timeout, just log it
    console.log('Clinical data load timed out, continuing without it');
  }, 8000);
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(clinicalTimeoutId);
      onClinicalDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(clinicalTimeoutId);
      console.warn('Clinical data load failed:', error);
      // Don't call onDataError for clinical data failures
      // Just continue without clinical data
    })
    .getClinicalData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
}

function onClinicalDataLoaded(data) {
  console.log('onClinicalDataLoaded called with:', data);
  // Don't hide loading here as it might interfere with main data loading
  // hideLoading();
  
  if (!data.success) {
    console.log('Clinical data load failed:', data.error);
    // Don't show error for clinical data, just log it
    console.warn('Clinical data unavailable:', data.error);
    return;
  }
  
  // L∆∞u d·ªØ li·ªáu v√†o bi·∫øn global
  clinicalData = data;
  console.log('clinicalData saved:', clinicalData);
  
  // Render clinical table asynchronously
  setTimeout(() => {
    try {
      renderClinicalTable(data);
      // Update charts after clinical data is rendered
      updateCharts();
    } catch (error) {
      console.error('Error rendering clinical data:', error);
    }
  }, 100);
}

function renderClinicalTable(clinicalData = null) {
  // N·∫øu kh√¥ng c√≥ data ƒë∆∞·ª£c truy·ªÅn v√†o, load data m·ªõi
  if (!clinicalData) {
    loadClinicalData();
    return;
  }
  
  if (!clinicalData.data || clinicalData.data.length === 0) {
    const clinicalContainer = document.querySelector('.clinical-container');
    if (clinicalContainer) {
      clinicalContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #64748b;">Kh√¥ng c√≥ d·ªØ li·ªáu c·∫≠n l√¢m s√†ng</div>';
    }
    return;
  }
  
  // S·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω t·ª´ server
  let data = clinicalData.data;
  let columns = clinicalData.columns;
  
  // √Åp d·ª•ng b·ªô l·ªçc timeFilter
  if (timeFilter && timeFilter !== 'all') {
    const today = new Date();
    const currentDate = `${today.getDate().toString().padStart(2, '0')}/${(today.getMonth() + 1).toString().padStart(2, '0')}`;
    
    data = data.filter(row => {
      switch(timeFilter) {
        case 'today':
          return row.date === currentDate || row.date.startsWith(currentDate) || row.dateKey === currentDate.replace('/', '');
        case 'week':
          // L·ªçc tu·∫ßn hi·ªán t·∫°i (t·ª´ ch·ªß nh·∫≠t ƒë·∫øn th·ª© 7)
          const currentDay = today.getDay(); // 0 = CN, 1 = T2, ...
          const daysSinceSunday = currentDay; // S·ªë ng√†y t·ª´ ch·ªß nh·∫≠t ƒë·∫øn h√¥m nay
          const sunday = new Date(today);
          sunday.setDate(today.getDate() - daysSinceSunday);
          
          const nextSunday = new Date(sunday);
          nextSunday.setDate(sunday.getDate() + 6);
          
          // Parse date t·ª´ row.date (format: DD/MM/YYYY)
          const dateParts = row.date.split('/');
          if (dateParts.length === 3) {
            const rowDate = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
            return rowDate >= sunday && rowDate <= nextSunday;
          }
          return false;
        case 'month':
          // Hi·ªÉn th·ªã th√°ng hi·ªán t·∫°i (m·∫∑c ƒë·ªãnh)
          return true;
        default:
          return true;
      }
    });
  }
  
  // √Åp d·ª•ng b·ªô l·ªçc shiftFilter
  if (shiftFilter && shiftFilter !== 'total') {
    columns = columns.filter(col => {
      if (shiftFilter === 'sang') {
        return col.shift === 'morning';
      } else if (shiftFilter === 'chieu') {
        return col.shift === 'afternoon';
      }
      return true;
    });
  }
  
  // Khi c√≥ searchCompany, ch·ªâ hi·ªÉn th·ªã nh·ªØng ng√†y c√≥ d·ªØ li·ªáu
  if (searchCompany && searchCompany.trim() !== '') {
    data = data.filter(row => {
      // Ki·ªÉm tra xem ng√†y n√†y c√≥ d·ªØ li·ªáu kh√¥ng (c√≥ √≠t nh·∫•t 1 gi√° tr·ªã > 0)
      return columns.some(col => (row[col.key] || 0) > 0);
    });
  }

  // T√≠nh t·ªïng cho t·ª´ng c·ªôt
  const totals = {};
  columns.forEach(col => {
    totals[col.key] = data.reduce((sum, row) => sum + (row[col.key] || 0), 0);
  });

  // T·∫°o HTML cho b·∫£ng v·ªõi 2 h√†ng header (S√°ng/Chi·ªÅu)
  let tableHTML = `
    <table class="clinical-table" id="clinicalTable">
      <thead>
        <tr class="clinical-header-row clinical-header-main">
          <th class="clinical-header company-header" rowspan="2">Ng√†y</th>
          <th class="clinical-header people-header" rowspan="2">Max</th>`;
  
  // T√≠nh s·ªë c·ªôt cho t·ª´ng ca
  const morningColumns = columns.filter(col => col.shift === 'morning');
  const afternoonColumns = columns.filter(col => col.shift === 'afternoon');
  
  // Hi·ªÉn th·ªã header theo b·ªô l·ªçc shift
  if (shiftFilter === 'sang' || shiftFilter === 'total') {
    if (morningColumns.length > 0) {
      tableHTML += `<th class="clinical-header" colspan="${morningColumns.length}">S√°ng</th>`;
    }
  }
  if (shiftFilter === 'chieu' || shiftFilter === 'total') {
    if (afternoonColumns.length > 0) {
      tableHTML += `<th class="clinical-header" colspan="${afternoonColumns.length}">Chi·ªÅu</th>`;
    }
  }
  
  tableHTML += `
        </tr>
        <tr class="clinical-header-row clinical-header-sub">
  `;
  
  // Th√™m header cho c√°c c·ªôt c·∫≠n l√¢m s√†ng theo th·ª© t·ª± ƒë√£ ƒë·ªãnh nghƒ©a
  columns.forEach(col => {
    const shortLabel = col.label.replace(' s√°ng', '').replace(' chi·ªÅu', '');
    tableHTML += `<th class="clinical-header">${shortLabel}</th>`;
  });
  
  tableHTML += `
        </tr>
      </thead>
      <tbody>
  `;
  
  // B·ªè h√†ng t·ªïng v√¨ ƒë√£ chuy·ªÉn sang hi·ªÉn th·ªã theo ng√†y

  // T·∫°o c√°c h√†ng d·ªØ li·ªáu theo ng√†y
  data.forEach(row => {
    const hasData = row.max > 0;
    const today = new Date();
    const currentDate = `${today.getDate().toString().padStart(2, '0')}/${(today.getMonth() + 1).toString().padStart(2, '0')}`;
    // Ki·ªÉm tra ng√†y hi·ªán t·∫°i v·ªõi nhi·ªÅu format kh√°c nhau
    const isToday = row.date === currentDate || row.date.startsWith(currentDate) || row.dateKey === currentDate.replace('/', '');
    
    // T√¨m gi√° tr·ªã l·ªõn nh·∫•t cho s√°ng v√† chi·ªÅu (ch·ªâ trong c√°c c·ªôt ƒë√£ ƒë∆∞·ª£c l·ªçc)
    const displayedMorningColumns = columns.filter(col => col.shift === 'morning');
    const displayedAfternoonColumns = columns.filter(col => col.shift === 'afternoon');
    
    let maxMorningValue = 0;
    let maxMorningKey = '';
    let maxAfternoonValue = 0;
    let maxAfternoonKey = '';
    
    displayedMorningColumns.forEach(col => {
      const value = row[col.key] || 0;
      if (value > maxMorningValue) {
        maxMorningValue = value;
        maxMorningKey = col.key;
      }
    });
    
    displayedAfternoonColumns.forEach(col => {
      const value = row[col.key] || 0;
      if (value > maxAfternoonValue) {
        maxAfternoonValue = value;
        maxAfternoonKey = col.key;
      }
    });
    
    tableHTML += `
      <tr class="clinical-row ${isToday ? 'today-row' : ''}">
        <td class="clinical-data-cell company-cell ${hasData ? 'clickable' : ''} ${isToday ? 'today-highlight' : ''}" ${hasData ? `onclick="showDayDetail('${row.dateKey}', '${row.date}')"` : ''}>
          ${row.date}
        </td>
        <td class="clinical-data-cell people-cell ${isToday ? 'today-column' : ''}">
          <div class="clinical-data-inner ${hasData ? 'has-data max-value' : 'empty'}">${hasData ? row.max : ''}</div>
        </td>
    `;
    
    columns.forEach(col => {
      const value = row[col.key] || 0;
      let cellClass = '';
      const isMaxValue = (col.key === maxMorningKey && maxMorningValue > 0) || (col.key === maxAfternoonKey && maxAfternoonValue > 0);
      
      if (value > 100) {
        cellClass = 'has-data high-volume';
      } else if (value > 0) {
        cellClass = 'has-data';
      } else {
        cellClass = 'empty';
      }
      
      if (isMaxValue) {
        cellClass += ' max-highlight';
      }
      
      // Th√™m class today-column cho t·∫•t c·∫£ c√°c c·ªôt thu·ªôc ng√†y hi·ªán t·∫°i
      if (isToday) {
        cellClass += ' today-column';
      }
      
      tableHTML += `
        <td class="clinical-data-cell ${cellClass} ${value > 0 ? 'clickable' : ''}" ${value > 0 ? `onclick="showClinicalColumnDetail('${col.key}', '${col.label}')"` : ''}>
          <div class="clinical-data-inner">${value > 0 ? value : ''}</div>
        </td>
      `;
    });
    
    tableHTML += `</tr>`;
  });



  tableHTML += `
      </tbody>
    </table>
  `;

  // C·∫≠p nh·∫≠t DOM
  const clinicalContainer = document.querySelector('.clinical-container');
  if (clinicalContainer) {
    clinicalContainer.innerHTML = tableHTML;
  }
}

// C·∫≠p nh·∫≠t h√†m renderDashboard ƒë·ªÉ bao g·ªìm b·∫£ng c·∫≠n l√¢m s√†ng
const originalRenderDashboard = renderDashboard;
renderDashboard = function(data) {
  // G·ªçi h√†m render dashboard g·ªëc
  originalRenderDashboard(data);
  
  // Render b·∫£ng c·∫≠n l√¢m s√†ng n·∫øu c√≥ d·ªØ li·ªáu
  if (clinicalData && clinicalData.data) {
    renderClinicalTable(clinicalData);
  }
};

// B·ªè h√†m showTotalDetail v√¨ kh√¥ng c√≤n h√†ng t·ªïng

// H√†m hi·ªÉn th·ªã chi ti·∫øt ng√†y khi click v√†o c·ªôt 'Ng√†y'
function showDayDetail(dateKey, dateDisplay) {
  console.log('showDayDetail called with:', dateKey, dateDisplay);
  console.log('clinicalData:', clinicalData);
  
  // Ki·ªÉm tra xem c√≥ ph·∫£i ng√†y ch·ªß nh·∫≠t kh√¥ng
  const dateParts = dateDisplay.split('/');
  if (dateParts.length === 3) {
    const dateObj = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
    if (isSunday(dateObj)) {
      // Hi·ªÉn th·ªã quote vui cho ng√†y ch·ªß nh·∫≠t
      const funQuotes = [
        "Ch·ªß nh·∫≠t: ƒë√≥ng c·ª≠a b·∫£o tr√¨.",
        // "‚òï H√£y th∆∞·ªüng th·ª©c m·ªôt t√°ch c√† ph√™ v√† th∆∞ gi√£n!",
        // "üéµ √Çm nh·∫°c v√† s√°ch l√† nh·ªØng ng∆∞·ªùi b·∫°n t·ªët nh·∫•t c·ªßa ng√†y ch·ªß nh·∫≠t!",
        // "üå∏ H√£y d√†nh th·ªùi gian cho gia ƒë√¨nh v√† nh·ªØng ng∆∞·ªùi th√¢n y√™u!",
        // "üßò‚Äç‚ôÄÔ∏è Thi·ªÅn ƒë·ªãnh v√† yoga s·∫Ω gi√∫p b·∫°n c√¢n b·∫±ng t√¢m h·ªìn!",
        // "üé® S√°ng t·∫°o v√† v·∫Ω v·ªùi s·∫Ω l√†m t√¢m h·ªìn b·∫°n phong ph√∫ h∆°n!",
        // "üìö ƒê·ªçc s√°ch l√† c√°ch tuy·ªát v·ªùi ƒë·ªÉ m·ªü r·ªông t·∫ßm nh√¨n!",
        // "üå≥ ƒêi d·∫°o trong c√¥ng vi√™n v√† h√≤a m√¨nh v·ªõi thi√™n nhi√™n!"
      ];
      
      const randomQuote = funQuotes[Math.floor(Math.random() * funQuotes.length)];
      
      const quoteHTML = `
        <div class="modal-header">
          <h3>Ng√†y Ch·ªß Nh·∫≠t ${dateDisplay}</h3>
          <span class="close" onclick="closeDetailModal()">&times;</span>
        </div>
        <div class="sunday-quote" style="text-align: center; padding: 40px 20px; font-size: 18px; line-height: 1.6; color: #2563eb;">
          <div style="font-size: 48px; margin-bottom: 20px;">üåû</div>
          <p style="margin: 0; font-weight: 500;">${randomQuote}</p>
          <div style="margin-top: 30px; font-size: 14px; color: #64748b;">
            <em>Relax!</em>
          </div>
        </div>
      `;
      
      document.getElementById('modalBody').innerHTML = quoteHTML;
      document.getElementById('detailModal').classList.add('show');
      return;
    }
  }
  
  if (!clinicalData || !clinicalData.data) {
    console.log('No clinical data available');
    alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã');
    return;
  }
  
  // T√¨m d·ªØ li·ªáu c·ªßa ng√†y ƒë∆∞·ª£c click
  const dayData = clinicalData.data.find(row => row.dateKey === dateKey);
  
  if (!dayData) {
    alert('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho ng√†y n√†y');
    return;
  }
  
  // Ph√¢n t√°ch c√°c h·∫°ng m·ª•c theo ca s√°ng v√† ca chi·ªÅu
  const morningCategories = [];
  const afternoonCategories = [];
  
  clinicalData.columns.forEach(col => {
    const value = dayData[col.key] || 0;
    if (value > 0) {
      const category = {
        label: col.label,
        value: value
      };
      
      if (col.shift === 'morning') {
        morningCategories.push(category);
      } else if (col.shift === 'afternoon') {
        afternoonCategories.push(category);
      }
    }
  });
  
  if (morningCategories.length === 0 && afternoonCategories.length === 0) {
    alert(`Kh√¥ng c√≥ d·ªØ li·ªáu c·∫≠n l√¢m s√†ng cho ng√†y ${dateDisplay}`);
    return;
  }
  
  // S·∫Øp x·∫øp theo s·ªë l∆∞·ª£ng gi·∫£m d·∫ßn
  morningCategories.sort((a, b) => b.value - a.value);
  afternoonCategories.sort((a, b) => b.value - a.value);
  
  const totalMorning = morningCategories.reduce((sum, item) => sum + item.value, 0);
  const totalAfternoon = afternoonCategories.reduce((sum, item) => sum + item.value, 0);
  const totalAll = totalMorning + totalAfternoon;
  
  let detailHTML = `
    <div class="modal-header">
      <h3>Chi ti·∫øt ng√†y ${dateDisplay}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-summary">
    </div>
  `;
  
  // Hi·ªÉn th·ªã ca s√°ng
  if (morningCategories.length > 0) {
    detailHTML += `
      <div class="shift-section">
        <h4 class="shift-title"> Ca S√°ng (${morningCategories.length} h·∫°ng m·ª•c)</h4>
        <div class="company-list">
    `;
    
    morningCategories.forEach(item => {
      detailHTML += `
        <div class="company-item">
          <span class="company-name">${item.label}</span>
          <span class="company-count ${item.value > 100 ? 'high-volume' : 'normal'}">${item.value}</span>
        </div>
      `;
    });
    
    detailHTML += `
        </div>
      </div>
    `;
  }
  
  // Hi·ªÉn th·ªã ca chi·ªÅu
  if (afternoonCategories.length > 0) {
    detailHTML += `
      <div class="shift-section">
        <h4 class="shift-title"> Ca Chi·ªÅu (${afternoonCategories.length} h·∫°ng m·ª•c)</h4>
        <div class="company-list">
    `;
    
    afternoonCategories.forEach(item => {
      detailHTML += `
        <div class="company-item">
          <span class="company-name">${item.label}</span>
          <span class="company-count ${item.value > 100 ? 'high-volume' : 'normal'}">${item.value}</span>
        </div>
      `;
    });
    
    detailHTML += `
        </div>
      </div>
    `;
  }
  
  detailHTML += `
  `;
  
  document.getElementById('modalBody').innerHTML = detailHTML;
  document.getElementById('detailModal').classList.add('show');
}

// H√†m hi·ªÉn th·ªã chi ti·∫øt c·ªôt c·∫≠n l√¢m s√†ng theo ng√†y
function showClinicalColumnDetail(columnKey, columnLabel) {
  if (!clinicalData || !clinicalData.data) {
    alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã');
    return;
  }
  
  // L·ªçc c√°c ng√†y c√≥ d·ªØ li·ªáu cho c·ªôt n√†y
  const daysWithData = clinicalData.data.filter(row => (row[columnKey] || 0) > 0);
  
  if (daysWithData.length === 0) {
    alert(`Kh√¥ng c√≥ ng√†y n√†o c√≥ d·ªØ li·ªáu cho ${columnLabel}`);
    return;
  }
  
  // S·∫Øp x·∫øp theo th·ª© t·ª± th·ªùi gian t·ª´ ng√†y ƒë·∫ßu ƒë·∫øn ng√†y cu·ªëi th√°ng
  daysWithData.sort((a, b) => {
    // Chuy·ªÉn ƒë·ªïi dateKey th√†nh s·ªë ƒë·ªÉ so s√°nh (dateKey c√≥ format YYYYMMDD)
    const dateA = parseInt(a.dateKey);
    const dateB = parseInt(b.dateKey);
    return dateA - dateB;
  });
  
  let detailHTML = `
    <div class="modal-header">
      <h3>Chi ti·∫øt ${columnLabel}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-summary">
      <p><strong>T·ªïng s·ªë ng√†y:</strong> ${daysWithData.length}</p>
    </div>
    <br>
    <div class="company-list">
  `;
  
  // L·∫•y ng√†y h√¥m nay ƒë·ªÉ highlight
  const today = new Date();
  const todayStr = String(today.getDate()).padStart(2, '0') + '/' + 
                   String(today.getMonth() + 1).padStart(2, '0') + '/' + 
                   today.getFullYear();
  
  daysWithData.forEach(row => {
    const count = row[columnKey] || 0;
    const isToday = row.date === todayStr;
    detailHTML += `
      <div class="company-item ${isToday ? 'today' : ''}">
        <span class="company-name">${row.date}</span>
        <span class="company-count ${count > 100 ? 'high-volume' : 'normal'}">${count}</span>
      </div>
    `;
  });
  
  detailHTML += `
      </div>
  `;
  
  document.getElementById('modalBody').innerHTML = detailHTML;
  document.getElementById('detailModal').classList.add('show');
}

// ƒê∆°n gi·∫£n h√≥a applyFilters - lu√¥n g·ªçi server ƒë·ªÉ ƒë·∫£m b·∫£o consistency
function applyFilters() {
  console.log('üîß Applying filters:', { searchCompany, filterEmployee, shiftFilter, timeFilter, showGold });
  
  // Prevent multiple simultaneous filter requests
  if (isLoading) {
    console.log('‚è≥ Filter request already in progress');
    return;
  }
  
  // Lu√¥n g·ªçi server ƒë·ªÉ ƒë·∫£m b·∫£o d·ªØ li·ªáu ch√≠nh x√°c
  loadDataWithCurrentFilters();
  setTimeout(() => {
    google.script.run
      .withSuccessHandler(onClinicalDataLoaded)
      .withFailureHandler(onDataError)
      .getClinicalData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  }, 200);
}

// Chart Functions
function createTotalPeopleChart(data) {
  const ctx = document.getElementById('totalPeopleChart');
  if (!ctx) return;
  
  // Destroy existing chart
  if (totalPeopleChart) {
    totalPeopleChart.destroy();
  }
  
  // Prepare data for chart
  const chartData = prepareChartData(data);
  
  // Get current date
  const today = new Date();
  const currentDay = today.getDate();
  
  // Create dynamic colors and sizes based on current date
  const pointColors = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? '#22c55e' : '#3b82f6'; // Green for today, blue for others 22c55e
  });
  
  const pointSizes = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? 8 : 6; // Larger for today, normal size for others
  });
  
  totalPeopleChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: 'T·ªïng ng∆∞·ªùi kh√°m',
        data: chartData.totalPeople,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.4,
        pointBackgroundColor: pointColors,
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        pointRadius: pointSizes,
        pointHoverRadius: pointSizes.map(size => size + 2)
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        intersect: false,
        mode: 'index'
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          borderColor: '#3b82f6',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: false,
          callbacks: {
            title: function(context) {
              return 'Ng√†y ' + context[0].label;
            },
            label: function(context) {
              return 'T·ªïng ng∆∞·ªùi kh√°m: ' + context.parsed.y + ' ng∆∞·ªùi';
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            },
            callback: function(value) {
              return value + ' ng∆∞·ªùi';
            }
          }
        }
      }
    }
  });
}

function createClinicalMaxChart(data) {
  const ctx = document.getElementById('clinicalMaxChart');
  if (!ctx || !data || !data.data) return;
  
  // Destroy existing chart
  if (clinicalMaxChart) {
    clinicalMaxChart.destroy();
  }
  
  // Prepare data for clinical chart
  const chartData = prepareClinicalChartData(data);
  
  // Get current date
  const today = new Date();
  const currentDay = today.getDate();
  
  // Create dynamic colors and sizes based on current date
  const pointColors = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? '#22c55e' : '#3b82f6'; // Green for today, blue for others
  });
  
  const pointSizes = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? 8 : 6; // Larger for today, normal size for others
  });
  
  clinicalMaxChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: 'Max c·∫≠n l√¢m s√†ng',
        data: chartData.maxValues,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.4,
        pointBackgroundColor: pointColors,
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        pointRadius: pointSizes,
        pointHoverRadius: pointSizes.map(size => size + 2)
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        intersect: false,
        mode: 'index'
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          borderColor: '#3b82f6',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: false,
          callbacks: {
            title: function(context) {
              return 'Ng√†y ' + context[0].label;
            },
            label: function(context) {
              return 'Max c·∫≠n l√¢m s√†ng: ' + context.parsed.y + ' ng∆∞·ªùi';
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            },
            callback: function(value) {
              return value + ' ng∆∞·ªùi';
            }
          }
        }
      }
    }
  });
}

function prepareChartData(data) {
  if (!data || !data.timeline || !data.timeline.dates || !data.timeline.rows || !data.timeline.weekdays) {
    return { labels: [], totalPeople: [] };
  }
  
  const labels = [];
  const totalPeople = [];
  
  // Calculate daily totals from timeline data
  const dailyTotals = new Array(data.timeline.dates.length).fill(0);
  
  // Sum up all companies for each day
  data.timeline.rows.forEach(row => {
    row.data.forEach((value, dayIndex) => {
      dailyTotals[dayIndex] += value;
    });
  });
  
  // Create chart data, excluding Sundays
  data.timeline.dates.forEach((date, index) => {
    const weekday = data.timeline.weekdays[index];
    // Skip Sundays (CN = Ch·ªß nh·∫≠t)
    if (weekday !== 'CN') {
      labels.push(date.toString());
      totalPeople.push(dailyTotals[index]);
    }
  });
  
  return { labels, totalPeople };
}

function prepareClinicalChartData(data) {
  if (!data || !data.data || !data.columns) {
    return { labels: [], maxValues: [] };
  }
  
  const labels = [];
  const maxValues = [];
  
  // Filter and sort data based on current filters
  let filteredData = data.data.slice();
  
  // Apply time filter
  if (timeFilter && timeFilter !== 'all') {
    const today = new Date();
    filteredData = filteredData.filter(row => {
      switch (timeFilter) {
        case 'today':
          const currentDate = today.getDate().toString().padStart(2, '0') + '/' + 
                             (today.getMonth() + 1).toString().padStart(2, '0') + '/' + 
                             today.getFullYear();
          return row.date === currentDate;
        case 'week':
          const weekAgo = new Date();
          weekAgo.setDate(today.getDate() - 7);
          const dateParts = row.date.split('/');
          if (dateParts.length === 3) {
            const rowDate = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
            return rowDate >= weekAgo && rowDate <= today;
          }
          return false;
        case 'month':
          return true;
        default:
          return true;
      }
    });
  }
  
  // Sort by date
  filteredData.sort((a, b) => {
    const dateA = parseInt(a.dateKey);
    const dateB = parseInt(b.dateKey);
    return dateA - dateB;
  });
  
  filteredData.forEach(row => {
    // Extract day from date (DD/MM/YYYY -> DD)
    const dayPart = row.date.split('/')[0];
    labels.push(dayPart);
    
    // Calculate max value for this day based on current shift filter
    let maxValue = 0;
    
    data.columns.forEach(col => {
      const value = row[col.key] || 0;
      
      // Apply shift filter
      if (shiftFilter === 'total' || 
          (shiftFilter === 'sang' && col.shift === 'morning') ||
          (shiftFilter === 'chieu' && col.shift === 'afternoon')) {
        if (value > maxValue) {
          maxValue = value;
        }
      }
    });
    
    maxValues.push(maxValue);
  });
  
  return { labels, maxValues };
}

// Update charts when data changes
function updateCharts() {
  if (dashboardData) {
    createTotalPeopleChart(dashboardData);
  }
  
  if (clinicalData) {
    createClinicalMaxChart(clinicalData);
  }
}

</script>