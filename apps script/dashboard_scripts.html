<script>
// Utility functions
function isSunday(date) {
  return date.getDay() === 0;
}

// Global state x.
let currentMonth = new Date().getMonth() + 1;
let currentYear = new Date().getFullYear();

let showGold = false;
let searchCompany = '';
let filterEmployee = '';
let shiftFilter = 'total'; // Mặc định là Tổng
let timeFilter = 'all'; // Mặc định là Tất cả thời gian
let dashboardData = null;
let originalData = null; // Keep original unfiltered data
let clinicalData = null;

// Chart instances
let totalPeopleChart = null;
let clinicalMaxChart = null;

// Debounce variables với tối ưu hóa - tách riêng cho từng filter
let searchDebounceTimer = null;
let employeeDebounceTimer = null;
let shiftDebounceTimer = null;
let timeDebounceTimer = null;
let goldDebounceTimer = null;
const DEBOUNCE_DELAY = 500; // Tăng lên 500ms để tránh spam requests

// Cache và performance optimization
let dataCache = {};
let lastLoadTime = 0;
const CACHE_DURATION = 30000; // 30 giây cache
let isLoading = false;
let pendingRequests = 0;

// Auto clear cache để tránh memory leak
setInterval(() => {
  const now = Date.now();
  const cacheKeys = Object.keys(dataCache);
  
  // Clear cache entries older than CACHE_DURATION
  cacheKeys.forEach(key => {
    if (now - lastLoadTime > CACHE_DURATION) {
      delete dataCache[key];
    }
  });
  
  // Log cache status
  if (cacheKeys.length > 5) {
    console.log('🧹 Cache cleanup: removed old entries');
    dataCache = {}; // Clear all if too many entries
  }
}, 60000); // Check every minute

// Initialize với safety mechanism
document.addEventListener('DOMContentLoaded', function() {
  initializeApp();
  loadCurrentMonth();
});

function initializeApp() {
  // Month navigation
  document.getElementById('prevMonth').addEventListener('click', () => {
    navigateMonth(-1);
  });
  
  document.getElementById('nextMonth').addEventListener('click', () => {
    navigateMonth(1);
  });
  
  // Search input - debounced search với timer riêng
  const searchInput = document.getElementById('companySearch');
  searchInput.addEventListener('input', (e) => {
    const value = e.target.value.trim();
    
    // Clear previous search timer
    if (searchDebounceTimer) {
      clearTimeout(searchDebounceTimer);
    }
    
    // Set new search timer
    searchDebounceTimer = setTimeout(() => {
      searchCompany = value;
      console.log('🔍 Search filter changed:', searchCompany);
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Also handle Enter key for immediate search
  searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      if (searchDebounceTimer) {
        clearTimeout(searchDebounceTimer);
      }
      searchCompany = e.target.value.trim();
      console.log('🔍 Search filter (Enter):', searchCompany);
      loadDataWithCurrentFilters();
    }
  });
  
  // Employee filter - với timer riêng
  document.getElementById('employeeFilter').addEventListener('change', (e) => {
    filterEmployee = e.target.value;
    console.log('👤 Employee filter changed:', filterEmployee);
    
    // Clear previous employee timer
    if (employeeDebounceTimer) {
      clearTimeout(employeeDebounceTimer);
    }
    
    // Set employee timer
    employeeDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Shift filter - với timer riêng
  document.getElementById('shiftFilter').addEventListener('change', (e) => {
    shiftFilter = e.target.value;
    console.log('🔧 Shift filter changed:', shiftFilter);
    
    // Clear previous shift timer
    if (shiftDebounceTimer) {
      clearTimeout(shiftDebounceTimer);
    }
    
    shiftDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Time filter - với timer riêng
  document.getElementById('timeFilter').addEventListener('change', (e) => {
    timeFilter = e.target.value;
    console.log('⏰ Time filter changed:', timeFilter);
    
    // Clear previous time timer
    if (timeDebounceTimer) {
      clearTimeout(timeDebounceTimer);
    }
    
    timeDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  // Gold filter checkbox - với timer riêng
  document.getElementById('showGold').addEventListener('change', (e) => {
    showGold = e.target.checked;
    console.log('⭐ Gold filter changed:', showGold);
    
    // Clear previous gold timer
    if (goldDebounceTimer) {
      clearTimeout(goldDebounceTimer);
    }
    
    goldDebounceTimer = setTimeout(() => {
      loadDataWithCurrentFilters();
    }, DEBOUNCE_DELAY);
  });
  
  updateMonthDisplay();
}

function navigateMonth(direction) {
  // Clear cache khi chuyển tháng để tránh hiển thị dữ liệu cũ
  dataCache = {};
  lastLoadTime = 0;
  
  currentMonth += direction;
  
  if (currentMonth > 12) {
    currentMonth = 1;
    currentYear++;
  } else if (currentMonth < 1) {
    currentMonth = 12;
    currentYear--;
  }
  
  updateMonthDisplay();
  loadData();
}

function updateMonthDisplay() {
  const monthNames = [
    '', 'Tháng 1', 'Tháng 2', 'Tháng 3', 'Tháng 4', 'Tháng 5', 'Tháng 6',
    'Tháng 7', 'Tháng 8', 'Tháng 9', 'Tháng 10', 'Tháng 11', 'Tháng 12'
  ];
  
  document.getElementById('currentMonthDisplay').textContent = 
    `${monthNames[currentMonth]} ${currentYear}`;
}

function loadCurrentMonth() {
  const now = new Date();
  currentMonth = now.getMonth() + 1;
  currentYear = now.getFullYear();
  updateMonthDisplay();
  loadData();
}

// Circuit breaker pattern for API calls - Tối ưu hóa
let failureCount = 0;
let lastFailureTime = 0;
const CIRCUIT_BREAKER_THRESHOLD = 5; // Tăng từ 3 lên 5
const CIRCUIT_BREAKER_TIMEOUT = 30000; // Giảm từ 60s xuống 30s

function isCircuitBreakerOpen() {
  if (failureCount >= CIRCUIT_BREAKER_THRESHOLD) {
    const timeSinceLastFailure = Date.now() - lastFailureTime;
    if (timeSinceLastFailure < CIRCUIT_BREAKER_TIMEOUT) {
      return true;
    } else {
      // Reset circuit breaker after timeout
      failureCount = 0;
    }
  }
  return false;
}

function recordFailure() {
  failureCount++;
  lastFailureTime = Date.now();
}

function recordSuccess() {
  failureCount = 0;
}

function loadData() {
  console.log('loadData called');
  
  // Prevent multiple simultaneous loads
  if (isLoading) {
    console.log('⏳ Already loading, skipping duplicate request');
    return;
  }
  
  // Check cache first để tăng tốc độ
  const cacheKey = `${currentMonth}_${currentYear}_${searchCompany}_${filterEmployee}_${shiftFilter}_${timeFilter}_${showGold}`;
  const now = Date.now();
  
  if (dataCache[cacheKey] && (now - lastLoadTime) < CACHE_DURATION) {
    console.log('📦 Using cached data');
    // Hiển thị thông báo ngắn về việc sử dụng cache
    showQuickMessage('Đang sử dụng dữ liệu đã lưu...');
    setTimeout(() => {
      onDataLoaded(dataCache[cacheKey]);
    }, 100);
    return;
  }
  
  // Check circuit breaker
  if (isCircuitBreakerOpen()) {
    showError('Hệ thống tạm thời không khả dụng. Vui lòng thử lại sau 30 giây.');
    return;
  }
  
  isLoading = true;
  pendingRequests++;
  showLoading();
  
  // Tăng timeout cho dữ liệu lớn
  const timeoutId = setTimeout(() => {
    console.warn('⚠️ API call timeout after 20 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('Tải dữ liệu quá lâu. Vui lòng thử lại.');
    
    // Không auto retry để tránh vòng lặp vô tận
    // Người dùng sẽ phải click thử lại thủ công
  }, 20000); // Tăng lên 20s cho dữ liệu lớn
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(timeoutId);
      isLoading = false;
      recordSuccess();
      
      // Cache dữ liệu để sử dụng lần sau
      dataCache[cacheKey] = data;
      lastLoadTime = now;
      
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(timeoutId);
      isLoading = false;
      recordFailure();
      console.error('❌ First attempt failed:', error);
      
      // Retry nhanh hơn cho network errors
      if (error.message && error.message.includes('network')) {
        setTimeout(() => {
          console.log('🔄 Network retry...');
          retryLoadData();
        }, 500);
      } else {
        // Exponential backoff với delay ngắn hơn
        const retryDelay = Math.min(1500 * Math.pow(2, failureCount - 1), 5000);
        setTimeout(() => {
          console.log('🔄 Retrying data load...');
          retryLoadData();
        }, retryDelay);
      }
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  
  // Load clinical data với delay ngắn hơn
  setTimeout(() => {
    console.log('Calling loadClinicalData...');
    loadClinicalData();
  }, 200);
}

function retryLoadData() {
  // Prevent infinite retry loops
  if (failureCount >= CIRCUIT_BREAKER_THRESHOLD) {
    hideLoading();
    showError('Hệ thống tạm thời không khả dụng. Vui lòng thử lại sau.');
    return;
  }
  
  // Timeout cho retry attempts
  const retryTimeoutId = setTimeout(() => {
    console.warn('⚠️ Retry timeout after 15 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('Không thể tải dữ liệu. Vui lòng thử lại thủ công.');
  }, 15000); // Tăng timeout cho retry
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(retryTimeoutId);
      isLoading = false;
      recordSuccess();
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(retryTimeoutId);
      isLoading = false;
      recordFailure();
      onDataError(error);
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
}

// Tối ưu hóa loadDataWithCurrentFilters với smart caching
function loadDataWithCurrentFilters() {
  // Prevent multiple simultaneous requests
  if (isLoading) {
    console.log('⏳ Filter request already in progress');
    return;
  }
  
  // Kiểm tra cache trước khi gọi server
  const cacheKey = `${currentMonth}_${currentYear}_${searchCompany}_${filterEmployee}_${shiftFilter}_${timeFilter}_${showGold}`;
  const now = Date.now();
  
  if (dataCache[cacheKey] && (now - lastLoadTime) < CACHE_DURATION) {
    console.log('📦 Sử dụng dữ liệu từ cache cho filter');
    showQuickMessage('Áp dụng bộ lọc từ dữ liệu đã lưu...');
    setTimeout(() => {
      onDataLoaded(dataCache[cacheKey]);
    }, 50);
    return;
  }
  
  isLoading = true;
  showLoading();
  
  // Timeout cho filter loading
  const filterTimeoutId = setTimeout(() => {
    console.warn('⚠️ Filter loading timeout after 15 seconds');
    hideLoading();
    isLoading = false;
    recordFailure();
    showError('Tải dữ liệu lọc quá lâu. Vui lòng thử lại thủ công.');
    
    // Không auto retry để tránh vòng lặp vô tận
  }, 15000); // Tăng timeout lên 15s
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(filterTimeoutId);
      isLoading = false;
      
      // Cache dữ liệu để sử dụng lần sau
      dataCache[cacheKey] = data;
      lastLoadTime = now;
      
      onDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(filterTimeoutId);
      isLoading = false;
      onDataError(error);
    })
    .getScheduleData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  
  // Load clinical data với delay ngắn hơn
  setTimeout(() => {
    loadClinicalData();
  }, 300);
}

function refreshData() {
  // Clear cache để force reload
  dataCache = {};
  lastLoadTime = 0;
  isLoading = false;
  pendingRequests = 0;
  
  showLoading();
  
  // Reset all filters
  searchCompany = '';
  filterEmployee = '';
  showGold = false;
  shiftFilter = 'total';
  timeFilter = 'all';
  document.getElementById('companySearch').value = '';
  document.getElementById('employeeFilter').value = '';
  document.getElementById('showGold').checked = false;
  document.getElementById('shiftFilter').value = 'total';
  document.getElementById('timeFilter').value = 'all';
  
  google.script.run
    .withSuccessHandler(onRefreshDataLoaded)
    .withFailureHandler(onDataError)
    .refreshCache();
}

function onDataLoaded(data) {
  console.log('✅ Data loaded successfully');
  pendingRequests = Math.max(0, pendingRequests - 1);
  
  if (!data.success) {
    hideLoading();
    showError(data.error || 'Có lỗi xảy ra khi tải dữ liệu');
    return;
  }
  
  console.log('📊 Data loaded with shiftFilter:', data.summary?.shiftFilter || 'unknown');
  console.log('📊 Data loaded with timeFilter:', data.summary?.timeFilter || 'all');
  
  // Cache data for faster subsequent loads
  originalData = JSON.parse(JSON.stringify(data)); // Deep clone
  dashboardData = data;
  
  // Tối ưu hóa progressive rendering với requestAnimationFrame
  try {
    // Step 1: Ẩn loading ngay lập tức để cải thiện UX
    hideLoading();
    
    // Step 2: Show dashboard structure
    showDashboard();
    
    // Step 3: Update filters (fast operation)
    updateEmployeeFilter(data.employees || []);
    
    // Step 4: Render content với requestAnimationFrame để smooth hơn
    requestAnimationFrame(() => {
      renderDashboard(dashboardData);
      
      // Step 5: Update charts sau khi render xong
      requestAnimationFrame(() => {
        updateCharts();
      });
    });
    
  } catch (error) {
    console.error('❌ Error rendering dashboard:', error);
    hideLoading();
    showError('Có lỗi khi hiển thị dữ liệu. Vui lòng thử lại.');
  }
}

function onRefreshDataLoaded(data) {
  onDataLoaded(data);
}

function onDataError(error) {
  hideLoading();
  showError(error.message || 'Không thể tải dữ liệu. Vui lòng thử lại.');
  console.error('Error:', error);
}

function updateEmployeeFilter(employees) {
  const select = document.getElementById('employeeFilter');
  
  // Keep current selection
  const currentValue = select.value;
  
  // Clear existing options except first
  select.innerHTML = '<option value="">Tất cả nhân viên</option>';
  
  // Add employee options
  employees.forEach(employee => {
    const option = document.createElement('option');
    option.value = employee;
    option.textContent = employee;
    select.appendChild(option);
  });
  
  // Restore selection if still valid
  if (currentValue && employees.includes(currentValue)) {
    select.value = currentValue;
  }
}

// Filter function đã được định nghĩa lại ở cuối file

function onFilterDataLoaded(data) {
  hideLoading();
  
  if (!data.success) {
    showError(data.error || 'Có lỗi xảy ra khi tải dữ liệu');
    return;
  }
  
  console.log('🔄 Filtered data loaded with shiftFilter:', data.summary?.shiftFilter || 'unknown');
  console.log('🔄 Filtered data loaded with timeFilter:', data.summary?.timeFilter || 'all');
  
  // Cập nhật data hiện tại
  dashboardData = data;
  
  renderDashboard(dashboardData);
  showDashboard();
  
  // Update charts
  updateCharts();
}

// Calculate statistics based on actual filtered data from server
function renderStats(summary) {
  // Sử dụng data từ server thay vì tính toán lại client-side
  document.getElementById('totalCompanies').textContent = formatNumber(summary.totalCompanies || 0);
  document.getElementById('completedCompanies').textContent = formatNumber(summary.completedCompanies || 0);
  document.getElementById('activeCompanies').textContent = formatNumber(summary.activeCompanies || 0);
  document.getElementById('averagePerDay').textContent = formatNumber(summary.averagePerDay || 0);
  
  console.log('📊 Stats rendered:', {
    total: summary.totalCompanies,
    completed: summary.completedCompanies,
    active: summary.activeCompanies,
    avg: summary.averagePerDay,
    filter: summary.shiftFilter,
    timeFilter: summary.timeFilter
  });
}

function formatNumber(num) {
  return new Intl.NumberFormat('vi-VN').format(num);
}

/**
 * Enhanced company name shortening - cố định cho 300px
 */
function shortenCompanyName(fullName) {
  const shortcuts = {
    'CÔNG TY CỔ PHẦN': 'CP',
    'CÔNG TY TNHH': 'TNHH',
    'CHI NHÁNH CÔNG TY': 'CN',
    'CÔNG TY CP': 'CP',
    'XUẤT NHẬP KHẨU': 'XNK',
    'THƯƠNG MẠI': 'TM',
    'DỊCH VỤ': 'DV',
    'KINH DOANH': 'KD',
    'PHÁT TRIỂN': 'PT',
    'ĐẦU TƯ': 'ĐT',
    'SẢN XUẤT': 'SX',
    'LOGISTICS': 'LOG',
    'INTERNATIONAL': 'INTL',
    'DEVELOPMENT': 'DEV',
    'TECHNOLOGY': 'TECH',
    'SOLUTIONS': 'SOL',
    'EDUCATION': 'EDU',
    'SOFTWARE': 'SW'
  };
  
  let shortened = fullName;
  
  // Apply shortcuts
  Object.keys(shortcuts).forEach(key => {
    const regex = new RegExp(key, 'gi');
    shortened = shortened.replace(regex, shortcuts[key]);
  });
  
  // Fixed max length for 300px column
  const maxLength = 35;
  if (shortened.length > maxLength) {
    shortened = shortened.substring(0, maxLength - 3) + '...';
  }
  
  return shortened;
}

function createTooltip(companyName, date, peopleCount) {
  return `${companyName}\nNgày ${date}: ${peopleCount} người khám`;
}

function renderDashboard(data) {
  renderStats(data.summary);
  renderTimeline(data.timeline);
}

function renderTimeline(timeline) {
  if (!timeline.dates || timeline.dates.length === 0) {
    document.getElementById('timelineBody').innerHTML = 
      '<tr><td colspan="100%" style="text-align: center; padding: 20px; color: #64748b;">Không có dữ liệu</td></tr>';
    return;
  }
  
  // Clear existing content
  const weekdayRow = document.getElementById('weekdayRow');
  const dateRow = document.getElementById('dateRow');
  const tbody = document.getElementById('timelineBody');
  
  // Reset headers - keep fixed columns
  weekdayRow.innerHTML = `
    <th class="company-header"></th>
    <th class="people-header"></th>
  `;
  dateRow.innerHTML = `
    <th class="company-header">Công ty</th>
    <th class="people-header">Người</th>
  `;
  tbody.innerHTML = '';
  
  const today = new Date();
  const isCurrentMonth = (currentMonth === today.getMonth() + 1) && (currentYear === today.getFullYear());
  const todayDate = today.getDate();
  
  // Create weekday and date headers
  timeline.dates.forEach((date, index) => {
    const weekday = timeline.weekdays[index];
    
    // Weekday header
    const weekdayTh = document.createElement('th');
    weekdayTh.textContent = weekday;
    weekdayTh.classList.add('weekday-header');
    
    // Date header
    const dateTh = document.createElement('th');
    dateTh.textContent = date;
    dateTh.classList.add('date-header');
    
    // Mark weekends
    if (weekday === 'CN' || weekday === 'T7') {
      weekdayTh.classList.add('weekend');
      dateTh.classList.add('weekend');
    }
    
    // Mark today - only headers
    if (isCurrentMonth && date === todayDate) {
      weekdayTh.classList.add('today');
      dateTh.classList.add('today');
    }
    
    weekdayRow.appendChild(weekdayTh);
    dateRow.appendChild(dateTh);
  });
  
  // Sắp xếp các hàng: công ty chưa khám xong trước (theo số người giảm dần), công ty đã khám xong sau (theo số người giảm dần)
  timeline.rows.sort((a, b) => {
    // Lấy thông tin trạng thái công ty từ timeline row và chuẩn hóa
    const statusA = (a.trangThai || '').toLowerCase().trim();
    const statusB = (b.trangThai || '').toLowerCase().trim();
    
    const isCompletedA = statusA === 'đã khám xong' || statusA === 'da kham xong';
    const isCompletedB = statusB === 'đã khám xong' || statusB === 'da kham xong';
    
    // Nếu một công ty đã khám xong và một công ty chưa khám xong
    if (isCompletedA !== isCompletedB) {
      return isCompletedA ? 1 : -1; // Chưa khám xong (false) lên trước
    }
    
    // Nếu cả hai cùng trạng thái, sắp xếp theo số người giảm dần
    return b.total - a.total;
  });
  
  // Calculate daily totals for the currently displayed companies
  const dailyTotalsFiltered = new Array(timeline.dates.length).fill(0);
  timeline.rows.forEach(row => {
    row.data.forEach((value, index) => {
      dailyTotalsFiltered[index] += value;
    });
  });

  // Add total row first
  const totalTr = document.createElement('tr');
  totalTr.classList.add('total-row', 'clickable');

  const totalCompanyCell = document.createElement('td');
  totalCompanyCell.classList.add('company-cell');
  totalCompanyCell.textContent = 'TỔNG';
  
  // Add click event for total details
  totalCompanyCell.addEventListener('click', () => {
    showTotalDetail();
  });
  
  totalTr.appendChild(totalCompanyCell);

  const totalPeopleCell = document.createElement('td');
  totalPeopleCell.classList.add('people-cell');
  const grandTotal = dailyTotalsFiltered.reduce((sum, val) => sum + val, 0);
  totalPeopleCell.textContent = formatNumber(grandTotal);
  totalTr.appendChild(totalPeopleCell);

  dailyTotalsFiltered.forEach((total, dayIndex) => {
    const td = document.createElement('td');
    td.classList.add('data-cell');
    const inner = document.createElement('div');
    inner.classList.add('data-cell-inner');
    inner.textContent = total > 0 ? total : '';
    if (total > 0) {
      td.classList.add('has-data');
      if (total > 100) {
        td.classList.add('high-volume');
      }
      
      // Thêm sự kiện click cho ô dữ liệu trong hàng tổng
      td.addEventListener('click', () => {
        showDailyTotalDetail(timeline.dates[dayIndex], dayIndex);
      });
      td.classList.add('clickable');
    } else {
      td.classList.add('empty');
    }
    // Mark weekends for total row
    const weekday = timeline.weekdays[dayIndex];  
    if (weekday === 'CN' || weekday === 'T7') {
      td.classList.add('weekend');
    }
    
    // Mark today column for total row
    const timelineDate = timeline.dates[dayIndex];
    if (isCurrentMonth && timelineDate === todayDate) {
      td.classList.add('today-column');
    }
    
    td.appendChild(inner);
    totalTr.appendChild(td);
  });
  tbody.appendChild(totalTr);
  
  // Create data rows
  timeline.rows.forEach(row => {
    const tr = document.createElement('tr');
    
    // Company name cell
    const companyCell = document.createElement('td');
    companyCell.classList.add('company-cell', 'clickable');
    const displayName = shortenCompanyName(row.company);
    companyCell.textContent = displayName;
    companyCell.title = row.company; // Full name on hover
    
    // Kiểm tra nếu công ty đã khám xong thì đổi màu chữ thành xanh lá cây
    const status = (row.trangThai || '').toLowerCase().trim();
    const isCompleted = status === 'đã khám xong' || status === 'da kham xong';
    if (isCompleted) {
      companyCell.style.color = '#007bff'; // Màu xanh lá cây
      companyCell.style.fontWeight = 'bold';
    }
    
    // Add click event for company details
    companyCell.addEventListener('click', () => {
      showCompanyDetail(row.company);
    });
    
    tr.appendChild(companyCell);
    
    // People count cell - Hiển thị tổng số người trong cả giai đoạn
    const peopleCell = document.createElement('td');
    peopleCell.classList.add('people-cell');
    
    // Lấy thông tin chi tiết công ty để tính tổng số người đúng
    let totalPeopleForCompany = 0;
    if (dashboardData && dashboardData.companyDetails && dashboardData.companyDetails[row.company]) {
      const companyDetail = dashboardData.companyDetails[row.company];
      totalPeopleForCompany = companyDetail.tongNguoi || 0;
    } else {
      // Fallback: sử dụng row.total nếu không có companyDetails
      totalPeopleForCompany = row.total || 0;
    }
    
    if (totalPeopleForCompany > 0) {
      peopleCell.textContent = formatNumber(totalPeopleForCompany);
    } else {
      peopleCell.textContent = '0';
    }
    tr.appendChild(peopleCell);
    
    // Data cells - Rounded design
    row.data.forEach((value, dayIndex) => {
      const td = document.createElement('td');
      td.classList.add('data-cell');
      
      const inner = document.createElement('div');
      inner.classList.add('data-cell-inner');
      
      // Kiểm tra ngày lấy máu trước khi xử lý dữ liệu khám
      const currentDay = timeline.dates[dayIndex];
      const currentDate = `${currentMonth}/${currentDay.toString().padStart(2, '0')}/${currentYear}`;
      let isBloodDate = false;
      
      if (row.ngayLayMau && typeof row.ngayLayMau === 'string') {
        // Chuẩn hóa định dạng ngày để so sánh
        const normalizedBloodDate = normalizeDate(row.ngayLayMau);
        const normalizedCurrentDate = normalizeDate(currentDate);
        const normalizedStartDate = normalizeDate(row.ngayBatDau);
        const normalizedEndDate = normalizeDate(row.ngayKetThuc);
        
        // Kiểm tra nếu ngày lấy máu trùng với ngày hiện tại
        if (normalizedBloodDate === normalizedCurrentDate) {
          isBloodDate = true;
          // Áp dụng màu vàng cho ngày lấy máu
          inner.style.backgroundColor = '#fdffb6';
          inner.style.color = '#2d6633';
          
          // Nếu không có dữ liệu khám nhưng là ngày lấy máu, chỉ hiển thị màu nền
          if (value === 0) {
            // Kiểm tra nếu ngày lấy máu khác ngày bắt đầu thì hiển thị icon 🩸
            if (normalizedBloodDate !== normalizedStartDate) {
              inner.textContent = '.'; // Thêm icon máu
            } else {
              inner.textContent = ''; // Ngày bắt đầu không có icon
            }
            inner.style.fontSize = '10px';
            inner.style.fontWeight = 'normal';
            td.classList.add('blood-date-only');
            td.title = `${row.company}\nNgày lấy máu: ${formatDate(row.ngayLayMau)}`;
          }
        }
      }
      
      if (value > 0) {
        inner.textContent = value;
        td.classList.add('has-data');
        
        // Highlight high volume (>100 people)
        if (value > 100) {
          td.classList.add('high-volume');
        }
        
        // Add tooltip
        let tooltipText = createTooltip(row.company, timeline.dates[dayIndex], value);
        if (isBloodDate) {
          tooltipText += `\nNgày lấy máu: ${formatDate(row.ngayLayMau)}`;
        }
        td.title = tooltipText;
        
      } else if (!isBloodDate) {
        inner.textContent = '';
        td.classList.add('empty');
      }
      
      // Mark weekends
      const weekday = timeline.weekdays[dayIndex];
      if (weekday === 'CN' || weekday === 'T7') {
        td.classList.add('weekend');
      }
      
      // Mark today column for data rows
      const timelineDate = timeline.dates[dayIndex];
      if (isCurrentMonth && timelineDate === todayDate) {
        td.classList.add('today-column');
      }
      
      td.appendChild(inner);
      tr.appendChild(td);
    });
    
    tbody.appendChild(tr);
  });
}

// Hàm định dạng ngày tháng năm theo mm/dd/yyyy (Google Sheets format)
function formatDate(dateString) {
  if (!dateString) return '';
  
  // Kiểm tra nếu dateString đã là định dạng mm/dd/yyyy
  if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
    return dateString;
  }
  
  // Nếu là định dạng ISO hoặc khác
  try {
    const date = new Date(dateString);
    if (isNaN(date.getTime())) return dateString; // Trả về nguyên bản nếu không phải ngày hợp lệ
    
    const day = date.getDate().toString().padStart(2, '0');
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const year = date.getFullYear();
    
    return `${month}/${day}/${year}`;
  } catch (e) {
    console.error('Lỗi định dạng ngày:', e);
    return dateString;
  }
}

// Hàm chuẩn hóa định dạng ngày để so sánh
function normalizeDate(dateString) {
  if (!dateString) return '';
  
  try {
    // Xử lý các định dạng khác nhau
    let normalizedDate = dateString.toString().trim();
    
    // Nếu là định dạng mm/dd/yyyy
    if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(normalizedDate)) {
      const parts = normalizedDate.split('/');
      const month = parts[0].padStart(2, '0');
      const day = parts[1].padStart(2, '0');
      const year = parts[2];
      return `${month}/${day}/${year}`;
    }
    
    // Nếu là định dạng dd/mm/yyyy hoặc yyyy-mm-dd
    const date = new Date(normalizedDate);
    if (!isNaN(date.getTime())) {
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const day = date.getDate().toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${month}/${day}/${year}`;
    }
    
    return normalizedDate;
  } catch (e) {
    console.error('Lỗi chuẩn hóa ngày:', e);
    return dateString;
  }
}

// Hàm kiểm tra ngày có nằm ngoài khoảng khám không
function isDateOutsideRange(bloodDate, startDate, endDate) {
  if (!bloodDate || !startDate || !endDate) return false;
  
  try {
    const blood = new Date(bloodDate);
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    return blood < start || blood > end;
  } catch (e) {
    console.error('Lỗi so sánh ngày:', e);
    return false;
  }
}

// Modal functions
function showCompanyDetail(companyName) {
  if (!dashboardData || !dashboardData.companyDetails) {
    console.log('Không có dữ liệu chi tiết công ty');
    return;
  }
  
  const companyDetail = dashboardData.companyDetails[companyName];
  if (!companyDetail) {
    console.log('Không tìm thấy thông tin chi tiết cho công ty:', companyName);
    return;
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Thêm thông tin filter vào title
  let titleText = companyName;
  if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    titleText += ' (Ca sáng)';
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    titleText += ' (Ca chiều)';
  }
  
  // Tính tổng số lượng khám sáng/chiều dựa trên shiftFilter hiện tại
  let displayMorning = 0;
  let displayAfternoon = 0;
  let displayTotal = 0;
  
  // Lấy tổng số ngày khám
  const totalDays = companyDetail.tongSoNgay || 0;
  
  if (shiftFilter === 'total') {
    // Hiển thị tổng số lượng khám chia đều 50/50
    displayTotal = companyDetail.tongNguoi || 0;
    displayMorning = Math.round(displayTotal / 2);
    displayAfternoon = displayTotal - displayMorning; // Đảm bảo tổng bằng displayTotal
  } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    // Chỉ hiển thị tổng ca sáng, ca chiều = 0
    displayMorning = (companyDetail.sang || 0) * totalDays;
    displayAfternoon = 0;
    displayTotal = displayMorning;
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    // Chỉ hiển thị tổng ca chiều, ca sáng = 0
    displayMorning = 0;
    displayAfternoon = (companyDetail.chieu || 0) * totalDays;
    displayTotal = displayAfternoon;
  }
  
  // Định dạng ngày bắt đầu và kết thúc khám
  const startDate = companyDetail.ngayBatDau || '';
  const endDate = companyDetail.ngayKetThuc || '';
  const dateRangeText = startDate && endDate ? `${startDate} - ${endDate}` : 'Chưa có thông tin';
  
  // 🔧 FIX: Apply formatNumber cho tất cả số liệu
  modalBody.innerHTML = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Số lượng khám sáng:</span>
      <span class="detail-value">${formatNumber(displayMorning)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Số lượng khám chiều:</span>
      <span class="detail-value">${formatNumber(displayAfternoon)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số người khám:</span>
      <span class="detail-value">${formatNumber(displayTotal)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số ngày khám:</span>
      <span class="detail-value">${formatNumber(companyDetail.tongSoNgay || 0)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Khoảng thời gian khám:</span>
      <span class="detail-value">${dateRangeText}</span>
    </div>
    ${companyDetail.employee ? `
    <div class="detail-row">
      <span class="detail-label">Nhân viên phụ trách:</span>
      <span class="detail-value">${companyDetail.employee}</span>
    </div>
    ` : ''}
    ${companyDetail.ngayLayMau ? `
    <div class="detail-row">
      <span class="detail-label">Ngày lấy máu:</span>
      <span class="detail-value">${formatDate(companyDetail.ngayLayMau)}</span>
    </div>
    ` : ''}
  `;
  
  modal.classList.add('show');
}

function showTotalDetail() {
  if (!dashboardData || !dashboardData.companyDetails) {
    console.log('Không có dữ liệu chi tiết');
    return;
  }
  
  // Tính tổng dựa trên companies đang hiển thị và current shiftFilter
  let totalSang = 0;
  let totalChieu = 0;
  let totalNguoi = 0;
  
  // Lọc theo công ty đang hiển thị trong dashboardData
  if (dashboardData && dashboardData.timeline && dashboardData.timeline.rows) {
    dashboardData.timeline.rows.forEach(row => {
      if (row.company && row.company !== 'TỔNG' && !row.isSpacing) {
        const companyDetail = dashboardData.companyDetails[row.company];
        if (companyDetail) {
          // Lấy tổng số ngày khám của công ty
          const totalDays = companyDetail.tongSoNgay || 0;
          
          // Tính toán tổng số lượng khám dựa trên shiftFilter hiện tại
          if (shiftFilter === 'total') {
            // Chỉ cộng dồn tổng số người khám, sau đó sẽ chia đều ở bên dưới
            totalNguoi += companyDetail.tongNguoi || 0;
          } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
            totalSang += (companyDetail.sang || 0) * totalDays;
            totalChieu = 0; // Không hiển thị ca chiều khi filter ca sáng
            totalNguoi += (companyDetail.sang || 0) * totalDays;
          } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
            totalSang = 0; // Không hiển thị ca sáng khi filter ca chiều
            totalChieu += (companyDetail.chieu || 0) * totalDays;
            totalNguoi += (companyDetail.chieu || 0) * totalDays;
          }
        }
      }
    });
  }
  
  // Nếu đang xem tổng (không filter), chia đều tổng số người khám thành hai phần bằng nhau
  if (shiftFilter === 'total') {
    totalSang = Math.round(totalNguoi / 2);
    totalChieu = totalNguoi - totalSang; // Đảm bảo tổng bằng totalNguoi
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Display title theo current filter
  let titleText = 'Tổng hợp tất cả công ty';
  if (shiftFilter === 'sang' || shiftFilter === 'morning') {
    titleText += ' (Ca sáng)';
  } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
    titleText += ' (Ca chiều)';
  }
  
  // Thêm thông tin về time filter
  if (timeFilter !== 'all') {
    const timeFilterText = timeFilter === 'today' ? 'Hôm nay' : 
                          timeFilter === 'week' ? 'Tuần này' : 
                          timeFilter === 'month' ? 'Tháng này' : '';
    if (timeFilterText) {
      titleText += ` - ${timeFilterText}`;
    }
  }
  
  // 🔧 FIX: Apply formatNumber cho tất cả số liệu
  modalBody.innerHTML = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số lượng khám sáng:</span>
      <span class="detail-value">${formatNumber(totalSang)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số lượng khám chiều:</span>
      <span class="detail-value">${formatNumber(totalChieu)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số người khám:</span>
      <span class="detail-value">${formatNumber(totalNguoi)}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Filter hiện tại:</span>
      <span class="detail-value">${shiftFilter === 'total' ? 'Tổng' : shiftFilter === 'sang' ? 'Sáng' : 'Chiều'}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Thời gian hiện tại:</span>
      <span class="detail-value">${timeFilter === 'all' ? 'Tất cả' : 
                                  timeFilter === 'today' ? 'Hôm nay' : 
                                  timeFilter === 'week' ? 'Tuần này' : 'Tháng này'}</span>
    </div>
  `;
  
  modal.classList.add('show');
}

/**
 * Hiển thị chi tiết cho một ngày cụ thể trong hàng tổng
 */
function showDailyTotalDetail(day, dayIndex) {
  if (!dashboardData || !dashboardData.timeline || !dashboardData.companyDetails) {
    console.log('Không có dữ liệu chi tiết ngày');
    return;
  }
  
  const timeline = dashboardData.timeline;
  const month = currentMonth;
  const year = currentYear;
  const dateStr = `${day}/${month}/${year}`;
  const weekday = timeline.weekdays[dayIndex];
  
  // Tính tổng số người khám trong ngày này cho tất cả công ty đang hiển thị
  let totalPeopleToday = 0;
  let companiesWithAppointments = [];
  
  // Tính số lượng khám sáng/chiều cho ngày này dựa trên shiftFilter hiện tại
  let morningExams = 0;
  let afternoonExams = 0;
  
  // Lọc theo công ty đang hiển thị trong dashboardData
  if (timeline && timeline.rows) {
    timeline.rows.forEach(row => {
      if (row.company && row.company !== 'TỔNG' && !row.isSpacing) {
        const peopleCount = row.data[dayIndex] || 0;
        
        if (peopleCount > 0) {
          totalPeopleToday += peopleCount;
          
          // Tính số lượng khám sáng/chiều dựa trên shiftFilter hiện tại
          if (shiftFilter === 'total') {
            // Không tính theo tỷ lệ thực tế của công ty nữa mà chia đều 50/50
            // Cộng dồn số người khám, sau đó sẽ chia đều ở bên dưới
          } else if (shiftFilter === 'sang' || shiftFilter === 'morning') {
            // Nếu đang filter ca sáng, tất cả số người đều là ca sáng
            morningExams += peopleCount;
            afternoonExams = 0;
          } else if (shiftFilter === 'chieu' || shiftFilter === 'afternoon') {
            // Nếu đang filter ca chiều, tất cả số người đều là ca chiều
            afternoonExams += peopleCount;
            morningExams = 0;
          }
          
          // Thêm vào danh sách công ty có lịch khám
          companiesWithAppointments.push({
            name: row.company,
            people: peopleCount,
            employee: row.employee || ''
          });
        }
      }
    });
  }
  
  // Sắp xếp theo nhân viên (A->Z) trước, sau đó theo số người khám giảm dần
  companiesWithAppointments.sort((a, b) => {
    // So sánh tên nhân viên trước
    const employeeA = a.employee || '';
    const employeeB = b.employee || '';
    const employeeComparison = employeeA.localeCompare(employeeB, 'vi', { sensitivity: 'base' });
    if (employeeComparison !== 0) {
      return employeeComparison;
    }
    // Nếu nhân viên giống nhau, sắp xếp theo số người giảm dần
    return b.people - a.people;
  });
  
  // Nếu đang xem tổng (không filter), chia đều tổng số người khám thành hai phần bằng nhau
  if (shiftFilter === 'total') {
    morningExams = Math.round(totalPeopleToday / 2);
    afternoonExams = totalPeopleToday - morningExams; // Đảm bảo tổng bằng totalPeopleToday
  }
  
  const modal = document.getElementById('detailModal');
  const modalBody = document.getElementById('modalBody');
  
  // Hiển thị tiêu đề với thông tin ngày
  const titleText = `Chi tiết ngày ${dateStr} (${weekday})`;
  
  // Tạo nội dung chi tiết
  let detailContent = `
    <div class="modal-header">
      <h3>${titleText}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Tổng số người khám:</span>
      <span class="detail-value">${totalPeopleToday}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Số lượng khám sáng:</span>
      <span class="detail-value">${morningExams}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Số lượng khám chiều:</span>
      <span class="detail-value">${afternoonExams}</span>
    </div>
    <div class="detail-row">
      <span class="detail-label">Số công ty có lịch khám:</span>
      <span class="detail-value">${companiesWithAppointments.length}</span>
    </div>
  `;
  
  // Thêm danh sách công ty có lịch khám
  if (companiesWithAppointments.length > 0) {
    detailContent += `
      <div class="detail-section">
        <h4 class="detail-section-title">Danh sách công ty có lịch khám:</h4>
        <div class="company-list">
    `;
    
    companiesWithAppointments.forEach(company => {
      detailContent += `
        <div class="company-list-item">
          <span class="company-name">${company.name}</span>
          <span class="company-people">${company.people} người</span>
          ${company.employee ? `<span class="company-employee">NV: ${getShortName(company.employee)}</span>` : ''}
        </div>
      `;
    });
    
    detailContent += `
        </div>
      </div>
    `;
  }
  
  modalBody.innerHTML = detailContent;
  modal.classList.add('show');
}

function closeDetailModal() {
  const modal = document.getElementById('detailModal');
  modal.classList.remove('show');
}

// Close modal when clicking outside
document.addEventListener('click', function(event) {
  const modal = document.getElementById('detailModal');
  if (event.target === modal) {
    closeDetailModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    closeDetailModal();
  }
});

// Helper function to get short name (only last name)
function getShortName(fullName) {
  if (!fullName) return '';
  const nameParts = fullName.trim().split(' ');
  return nameParts[nameParts.length - 1]; // Lấy từ cuối cùng
}

// UI State Management
function showLoading() {
  document.getElementById('loading').style.display = 'flex';
  document.getElementById('error').style.display = 'none';
  document.getElementById('dashboard').style.display = 'none';
}

function hideLoading() {
  document.getElementById('loading').style.display = 'none';
}

function showError(message) {
  document.getElementById('errorMessage').textContent = message;
  document.getElementById('error').style.display = 'block';
  document.getElementById('dashboard').style.display = 'none';
}

// Hàm hiển thị thông báo nhanh cho cache
function showQuickMessage(message) {
  const loadingDiv = document.getElementById('loading');
  const loadingText = loadingDiv.querySelector('div');
  if (loadingText) {
    const originalText = loadingText.textContent;
    loadingText.textContent = message;
    loadingDiv.style.display = 'flex';
    
    // Hide after short delay
    setTimeout(() => {
      loadingDiv.style.display = 'none';
      loadingText.textContent = originalText;
    }, 800);
  }
}

function showDashboard() {
  document.getElementById('error').style.display = 'none';
  document.getElementById('dashboard').style.display = 'block';
}

// Enhanced keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey || e.metaKey) {
    switch(e.key) {
      case 'r':
        e.preventDefault();
        refreshData();
        break;
      case 'ArrowLeft':
        e.preventDefault();
        navigateMonth(-1);
        break;
      case 'ArrowRight':
        e.preventDefault();
        navigateMonth(1);
        break;
      case 'f':
        e.preventDefault();
        // Removed showCompleted functionality
        break;
      case 'k':
        e.preventDefault();
        document.getElementById('companySearch').focus();
        break;
    }
  }
});

// Error handling
window.addEventListener('error', (e) => {
  console.error('JavaScript error:', e.error);
  if (document.getElementById('loading').style.display !== 'none') {
    showError('Có lỗi xảy ra. Vui lòng tải lại trang.');
  }
});

// Smart auto-refresh with user activity detection
let lastUserActivity = Date.now();
let autoRefreshEnabled = true;

// Track user activity
['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(event => {
  document.addEventListener(event, () => {
    lastUserActivity = Date.now();
  }, { passive: true });
});

// Auto-refresh only when user is inactive for 2+ minutes
setInterval(() => {
  const timeSinceActivity = Date.now() - lastUserActivity;
  const isUserIdle = timeSinceActivity > 2 * 60 * 1000; // 2 minutes
  
  if (autoRefreshEnabled && 
      isUserIdle && 
      document.getElementById('dashboard').style.display === 'block' &&
      !isCircuitBreakerOpen()) {
    console.log('🔄 Auto-refreshing data (user idle)');
    loadData();
  }
}, 5 * 60 * 1000); // Check every 5 minutes

// Allow users to disable auto-refresh
function toggleAutoRefresh() {
  autoRefreshEnabled = !autoRefreshEnabled;
  console.log('Auto-refresh:', autoRefreshEnabled ? 'enabled' : 'disabled');
}

// Clinical Examination Table Functions
function loadClinicalData() {
  console.log('loadClinicalData called with params:', {
    currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold
  });
  
  // Don't show loading for clinical data to avoid blocking main UI
  // showLoading();
  
  // Add timeout for clinical data
  const clinicalTimeoutId = setTimeout(() => {
    console.warn('⚠️ Clinical data timeout after 8 seconds');
    // Don't show error for clinical data timeout, just log it
    console.log('Clinical data load timed out, continuing without it');
  }, 8000);
  
  google.script.run
    .withSuccessHandler((data) => {
      clearTimeout(clinicalTimeoutId);
      onClinicalDataLoaded(data);
    })
    .withFailureHandler((error) => {
      clearTimeout(clinicalTimeoutId);
      console.warn('Clinical data load failed:', error);
      // Don't call onDataError for clinical data failures
      // Just continue without clinical data
    })
    .getClinicalData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
}

function onClinicalDataLoaded(data) {
  console.log('onClinicalDataLoaded called with:', data);
  // Don't hide loading here as it might interfere with main data loading
  // hideLoading();
  
  if (!data.success) {
    console.log('Clinical data load failed:', data.error);
    // Don't show error for clinical data, just log it
    console.warn('Clinical data unavailable:', data.error);
    return;
  }
  
  // Lưu dữ liệu vào biến global
  clinicalData = data;
  console.log('clinicalData saved:', clinicalData);
  
  // Render clinical table asynchronously
  setTimeout(() => {
    try {
      renderClinicalTable(data);
      // Update charts after clinical data is rendered
      updateCharts();
    } catch (error) {
      console.error('Error rendering clinical data:', error);
    }
  }, 100);
}

function renderClinicalTable(clinicalData = null) {
  // Nếu không có data được truyền vào, load data mới
  if (!clinicalData) {
    loadClinicalData();
    return;
  }
  
  if (!clinicalData.data || clinicalData.data.length === 0) {
    const clinicalContainer = document.querySelector('.clinical-container');
    if (clinicalContainer) {
      clinicalContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: #64748b;">Không có dữ liệu cận lâm sàng</div>';
    }
    return;
  }
  
  // Sử dụng dữ liệu đã được xử lý từ server
  let data = clinicalData.data;
  let columns = clinicalData.columns;
  
  // Áp dụng bộ lọc timeFilter
  if (timeFilter && timeFilter !== 'all') {
    const today = new Date();
    const currentDate = `${today.getDate().toString().padStart(2, '0')}/${(today.getMonth() + 1).toString().padStart(2, '0')}`;
    
    data = data.filter(row => {
      switch(timeFilter) {
        case 'today':
          return row.date === currentDate || row.date.startsWith(currentDate) || row.dateKey === currentDate.replace('/', '');
        case 'week':
          // Lọc tuần hiện tại (từ chủ nhật đến thứ 7)
          const currentDay = today.getDay(); // 0 = CN, 1 = T2, ...
          const daysSinceSunday = currentDay; // Số ngày từ chủ nhật đến hôm nay
          const sunday = new Date(today);
          sunday.setDate(today.getDate() - daysSinceSunday);
          
          const nextSunday = new Date(sunday);
          nextSunday.setDate(sunday.getDate() + 6);
          
          // Parse date từ row.date (format: DD/MM/YYYY)
          const dateParts = row.date.split('/');
          if (dateParts.length === 3) {
            const rowDate = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
            return rowDate >= sunday && rowDate <= nextSunday;
          }
          return false;
        case 'month':
          // Hiển thị tháng hiện tại (mặc định)
          return true;
        default:
          return true;
      }
    });
  }
  
  // Áp dụng bộ lọc shiftFilter
  if (shiftFilter && shiftFilter !== 'total') {
    columns = columns.filter(col => {
      if (shiftFilter === 'sang') {
        return col.shift === 'morning';
      } else if (shiftFilter === 'chieu') {
        return col.shift === 'afternoon';
      }
      return true;
    });
  }
  
  // Khi có searchCompany, chỉ hiển thị những ngày có dữ liệu
  if (searchCompany && searchCompany.trim() !== '') {
    data = data.filter(row => {
      // Kiểm tra xem ngày này có dữ liệu không (có ít nhất 1 giá trị > 0)
      return columns.some(col => (row[col.key] || 0) > 0);
    });
  }

  // Tính tổng cho từng cột
  const totals = {};
  columns.forEach(col => {
    totals[col.key] = data.reduce((sum, row) => sum + (row[col.key] || 0), 0);
  });

  // Tạo HTML cho bảng với 2 hàng header (Sáng/Chiều)
  let tableHTML = `
    <table class="clinical-table" id="clinicalTable">
      <thead>
        <tr class="clinical-header-row clinical-header-main">
          <th class="clinical-header company-header" rowspan="2">Ngày</th>
          <th class="clinical-header people-header" rowspan="2">Max</th>`;
  
  // Tính số cột cho từng ca
  const morningColumns = columns.filter(col => col.shift === 'morning');
  const afternoonColumns = columns.filter(col => col.shift === 'afternoon');
  
  // Hiển thị header theo bộ lọc shift
  if (shiftFilter === 'sang' || shiftFilter === 'total') {
    if (morningColumns.length > 0) {
      tableHTML += `<th class="clinical-header" colspan="${morningColumns.length}">Sáng</th>`;
    }
  }
  if (shiftFilter === 'chieu' || shiftFilter === 'total') {
    if (afternoonColumns.length > 0) {
      tableHTML += `<th class="clinical-header" colspan="${afternoonColumns.length}">Chiều</th>`;
    }
  }
  
  tableHTML += `
        </tr>
        <tr class="clinical-header-row clinical-header-sub">
  `;
  
  // Thêm header cho các cột cận lâm sàng theo thứ tự đã định nghĩa
  columns.forEach(col => {
    const shortLabel = col.label.replace(' sáng', '').replace(' chiều', '');
    tableHTML += `<th class="clinical-header">${shortLabel}</th>`;
  });
  
  tableHTML += `
        </tr>
      </thead>
      <tbody>
  `;
  
  // Bỏ hàng tổng vì đã chuyển sang hiển thị theo ngày

  // Tạo các hàng dữ liệu theo ngày
  data.forEach(row => {
    const hasData = row.max > 0;
    const today = new Date();
    const currentDate = `${today.getDate().toString().padStart(2, '0')}/${(today.getMonth() + 1).toString().padStart(2, '0')}`;
    // Kiểm tra ngày hiện tại với nhiều format khác nhau
    const isToday = row.date === currentDate || row.date.startsWith(currentDate) || row.dateKey === currentDate.replace('/', '');
    
    // Tìm giá trị lớn nhất cho sáng và chiều (chỉ trong các cột đã được lọc)
    const displayedMorningColumns = columns.filter(col => col.shift === 'morning');
    const displayedAfternoonColumns = columns.filter(col => col.shift === 'afternoon');
    
    let maxMorningValue = 0;
    let maxMorningKey = '';
    let maxAfternoonValue = 0;
    let maxAfternoonKey = '';
    
    displayedMorningColumns.forEach(col => {
      const value = row[col.key] || 0;
      if (value > maxMorningValue) {
        maxMorningValue = value;
        maxMorningKey = col.key;
      }
    });
    
    displayedAfternoonColumns.forEach(col => {
      const value = row[col.key] || 0;
      if (value > maxAfternoonValue) {
        maxAfternoonValue = value;
        maxAfternoonKey = col.key;
      }
    });
    
    tableHTML += `
      <tr class="clinical-row ${isToday ? 'today-row' : ''}">
        <td class="clinical-data-cell company-cell ${hasData ? 'clickable' : ''} ${isToday ? 'today-highlight' : ''}" ${hasData ? `onclick="showDayDetail('${row.dateKey}', '${row.date}')"` : ''}>
          ${row.date}
        </td>
        <td class="clinical-data-cell people-cell ${isToday ? 'today-column' : ''}">
          <div class="clinical-data-inner ${hasData ? 'has-data max-value' : 'empty'}">${hasData ? row.max : ''}</div>
        </td>
    `;
    
    columns.forEach(col => {
      const value = row[col.key] || 0;
      let cellClass = '';
      const isMaxValue = (col.key === maxMorningKey && maxMorningValue > 0) || (col.key === maxAfternoonKey && maxAfternoonValue > 0);
      
      if (value > 100) {
        cellClass = 'has-data high-volume';
      } else if (value > 0) {
        cellClass = 'has-data';
      } else {
        cellClass = 'empty';
      }
      
      if (isMaxValue) {
        cellClass += ' max-highlight';
      }
      
      // Thêm class today-column cho tất cả các cột thuộc ngày hiện tại
      if (isToday) {
        cellClass += ' today-column';
      }
      
      tableHTML += `
        <td class="clinical-data-cell ${cellClass} ${value > 0 ? 'clickable' : ''}" ${value > 0 ? `onclick="showClinicalColumnDetail('${col.key}', '${col.label}')"` : ''}>
          <div class="clinical-data-inner">${value > 0 ? value : ''}</div>
        </td>
      `;
    });
    
    tableHTML += `</tr>`;
  });



  tableHTML += `
      </tbody>
    </table>
  `;

  // Cập nhật DOM
  const clinicalContainer = document.querySelector('.clinical-container');
  if (clinicalContainer) {
    clinicalContainer.innerHTML = tableHTML;
  }
}

// Cập nhật hàm renderDashboard để bao gồm bảng cận lâm sàng
const originalRenderDashboard = renderDashboard;
renderDashboard = function(data) {
  // Gọi hàm render dashboard gốc
  originalRenderDashboard(data);
  
  // Render bảng cận lâm sàng nếu có dữ liệu
  if (clinicalData && clinicalData.data) {
    renderClinicalTable(clinicalData);
  }
};

// Bỏ hàm showTotalDetail vì không còn hàng tổng

// Hàm hiển thị chi tiết ngày khi click vào cột 'Ngày'
function showDayDetail(dateKey, dateDisplay) {
  console.log('showDayDetail called with:', dateKey, dateDisplay);
  console.log('clinicalData:', clinicalData);
  
  // Kiểm tra xem có phải ngày chủ nhật không
  const dateParts = dateDisplay.split('/');
  if (dateParts.length === 3) {
    const dateObj = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
    if (isSunday(dateObj)) {
      // Hiển thị quote vui cho ngày chủ nhật
      const funQuotes = [
        "Chủ nhật: đóng cửa bảo trì.",
        // "☕ Hãy thưởng thức một tách cà phê và thư giãn!",
        // "🎵 Âm nhạc và sách là những người bạn tốt nhất của ngày chủ nhật!",
        // "🌸 Hãy dành thời gian cho gia đình và những người thân yêu!",
        // "🧘‍♀️ Thiền định và yoga sẽ giúp bạn cân bằng tâm hồn!",
        // "🎨 Sáng tạo và vẽ vời sẽ làm tâm hồn bạn phong phú hơn!",
        // "📚 Đọc sách là cách tuyệt vời để mở rộng tầm nhìn!",
        // "🌳 Đi dạo trong công viên và hòa mình với thiên nhiên!"
      ];
      
      const randomQuote = funQuotes[Math.floor(Math.random() * funQuotes.length)];
      
      const quoteHTML = `
        <div class="modal-header">
          <h3>Ngày Chủ Nhật ${dateDisplay}</h3>
          <span class="close" onclick="closeDetailModal()">&times;</span>
        </div>
        <div class="sunday-quote" style="text-align: center; padding: 40px 20px; font-size: 18px; line-height: 1.6; color: #2563eb;">
          <div style="font-size: 48px; margin-bottom: 20px;">🌞</div>
          <p style="margin: 0; font-weight: 500;">${randomQuote}</p>
          <div style="margin-top: 30px; font-size: 14px; color: #64748b;">
            <em>Relax!</em>
          </div>
        </div>
      `;
      
      document.getElementById('modalBody').innerHTML = quoteHTML;
      document.getElementById('detailModal').classList.add('show');
      return;
    }
  }
  
  if (!clinicalData || !clinicalData.data) {
    console.log('No clinical data available');
    alert('Không có dữ liệu để hiển thị');
    return;
  }
  
  // Tìm dữ liệu của ngày được click
  const dayData = clinicalData.data.find(row => row.dateKey === dateKey);
  
  if (!dayData) {
    alert('Không tìm thấy dữ liệu cho ngày này');
    return;
  }
  
  // Phân tách các hạng mục theo ca sáng và ca chiều
  const morningCategories = [];
  const afternoonCategories = [];
  
  clinicalData.columns.forEach(col => {
    const value = dayData[col.key] || 0;
    if (value > 0) {
      const category = {
        label: col.label,
        value: value
      };
      
      if (col.shift === 'morning') {
        morningCategories.push(category);
      } else if (col.shift === 'afternoon') {
        afternoonCategories.push(category);
      }
    }
  });
  
  if (morningCategories.length === 0 && afternoonCategories.length === 0) {
    alert(`Không có dữ liệu cận lâm sàng cho ngày ${dateDisplay}`);
    return;
  }
  
  // Sắp xếp theo số lượng giảm dần
  morningCategories.sort((a, b) => b.value - a.value);
  afternoonCategories.sort((a, b) => b.value - a.value);
  
  const totalMorning = morningCategories.reduce((sum, item) => sum + item.value, 0);
  const totalAfternoon = afternoonCategories.reduce((sum, item) => sum + item.value, 0);
  const totalAll = totalMorning + totalAfternoon;
  
  let detailHTML = `
    <div class="modal-header">
      <h3>Chi tiết ngày ${dateDisplay}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-summary">
    </div>
  `;
  
  // Hiển thị ca sáng
  if (morningCategories.length > 0) {
    detailHTML += `
      <div class="shift-section">
        <h4 class="shift-title"> Ca Sáng (${morningCategories.length} hạng mục)</h4>
        <div class="company-list">
    `;
    
    morningCategories.forEach(item => {
      detailHTML += `
        <div class="company-item">
          <span class="company-name">${item.label}</span>
          <span class="company-count ${item.value > 100 ? 'high-volume' : 'normal'}">${item.value}</span>
        </div>
      `;
    });
    
    detailHTML += `
        </div>
      </div>
    `;
  }
  
  // Hiển thị ca chiều
  if (afternoonCategories.length > 0) {
    detailHTML += `
      <div class="shift-section">
        <h4 class="shift-title"> Ca Chiều (${afternoonCategories.length} hạng mục)</h4>
        <div class="company-list">
    `;
    
    afternoonCategories.forEach(item => {
      detailHTML += `
        <div class="company-item">
          <span class="company-name">${item.label}</span>
          <span class="company-count ${item.value > 100 ? 'high-volume' : 'normal'}">${item.value}</span>
        </div>
      `;
    });
    
    detailHTML += `
        </div>
      </div>
    `;
  }
  
  detailHTML += `
  `;
  
  document.getElementById('modalBody').innerHTML = detailHTML;
  document.getElementById('detailModal').classList.add('show');
}

// Hàm hiển thị chi tiết cột cận lâm sàng theo ngày
function showClinicalColumnDetail(columnKey, columnLabel) {
  if (!clinicalData || !clinicalData.data) {
    alert('Không có dữ liệu để hiển thị');
    return;
  }
  
  // Lọc các ngày có dữ liệu cho cột này
  const daysWithData = clinicalData.data.filter(row => (row[columnKey] || 0) > 0);
  
  if (daysWithData.length === 0) {
    alert(`Không có ngày nào có dữ liệu cho ${columnLabel}`);
    return;
  }
  
  // Sắp xếp theo thứ tự thời gian từ ngày đầu đến ngày cuối tháng
  daysWithData.sort((a, b) => {
    // Chuyển đổi dateKey thành số để so sánh (dateKey có format YYYYMMDD)
    const dateA = parseInt(a.dateKey);
    const dateB = parseInt(b.dateKey);
    return dateA - dateB;
  });
  
  let detailHTML = `
    <div class="modal-header">
      <h3>Chi tiết ${columnLabel}</h3>
      <span class="close" onclick="closeDetailModal()">&times;</span>
    </div>
    <div class="detail-summary">
      <p><strong>Tổng số ngày:</strong> ${daysWithData.length}</p>
    </div>
    <br>
    <div class="company-list">
  `;
  
  // Lấy ngày hôm nay để highlight
  const today = new Date();
  const todayStr = String(today.getDate()).padStart(2, '0') + '/' + 
                   String(today.getMonth() + 1).padStart(2, '0') + '/' + 
                   today.getFullYear();
  
  daysWithData.forEach(row => {
    const count = row[columnKey] || 0;
    const isToday = row.date === todayStr;
    detailHTML += `
      <div class="company-item ${isToday ? 'today' : ''}">
        <span class="company-name">${row.date}</span>
        <span class="company-count ${count > 100 ? 'high-volume' : 'normal'}">${count}</span>
      </div>
    `;
  });
  
  detailHTML += `
      </div>
  `;
  
  document.getElementById('modalBody').innerHTML = detailHTML;
  document.getElementById('detailModal').classList.add('show');
}

// Đơn giản hóa applyFilters - luôn gọi server để đảm bảo consistency
function applyFilters() {
  console.log('🔧 Applying filters:', { searchCompany, filterEmployee, shiftFilter, timeFilter, showGold });
  
  // Prevent multiple simultaneous filter requests
  if (isLoading) {
    console.log('⏳ Filter request already in progress');
    return;
  }
  
  // Luôn gọi server để đảm bảo dữ liệu chính xác
  loadDataWithCurrentFilters();
  setTimeout(() => {
    google.script.run
      .withSuccessHandler(onClinicalDataLoaded)
      .withFailureHandler(onDataError)
      .getClinicalData(currentMonth, currentYear, searchCompany, filterEmployee, shiftFilter, timeFilter, showGold);
  }, 200);
}

// Chart Functions
function createTotalPeopleChart(data) {
  const ctx = document.getElementById('totalPeopleChart');
  if (!ctx) return;
  
  // Destroy existing chart
  if (totalPeopleChart) {
    totalPeopleChart.destroy();
  }
  
  // Prepare data for chart
  const chartData = prepareChartData(data);
  
  // Get current date
  const today = new Date();
  const currentDay = today.getDate();
  
  // Create dynamic colors and sizes based on current date
  const pointColors = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? '#22c55e' : '#3b82f6'; // Green for today, blue for others 22c55e
  });
  
  const pointSizes = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? 8 : 6; // Larger for today, normal size for others
  });
  
  totalPeopleChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: 'Tổng người khám',
        data: chartData.totalPeople,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.4,
        pointBackgroundColor: pointColors,
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        pointRadius: pointSizes,
        pointHoverRadius: pointSizes.map(size => size + 2)
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        intersect: false,
        mode: 'index'
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          borderColor: '#3b82f6',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: false,
          callbacks: {
            title: function(context) {
              return 'Ngày ' + context[0].label;
            },
            label: function(context) {
              return 'Tổng người khám: ' + context.parsed.y + ' người';
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            },
            callback: function(value) {
              return value + ' người';
            }
          }
        }
      }
    }
  });
}

function createClinicalMaxChart(data) {
  const ctx = document.getElementById('clinicalMaxChart');
  if (!ctx || !data || !data.data) return;
  
  // Destroy existing chart
  if (clinicalMaxChart) {
    clinicalMaxChart.destroy();
  }
  
  // Prepare data for clinical chart
  const chartData = prepareClinicalChartData(data);
  
  // Get current date
  const today = new Date();
  const currentDay = today.getDate();
  
  // Create dynamic colors and sizes based on current date
  const pointColors = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? '#22c55e' : '#3b82f6'; // Green for today, blue for others
  });
  
  const pointSizes = chartData.labels.map(label => {
    const day = parseInt(label);
    return day === currentDay ? 8 : 6; // Larger for today, normal size for others
  });
  
  clinicalMaxChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: chartData.labels,
      datasets: [{
        label: 'Max cận lâm sàng',
        data: chartData.maxValues,
        borderColor: '#3b82f6',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        borderWidth: 3,
        fill: true,
        tension: 0.4,
        pointBackgroundColor: pointColors,
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        pointRadius: pointSizes,
        pointHoverRadius: pointSizes.map(size => size + 2)
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        intersect: false,
        mode: 'index'
      },
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          borderColor: '#3b82f6',
          borderWidth: 1,
          cornerRadius: 8,
          displayColors: false,
          callbacks: {
            title: function(context) {
              return 'Ngày ' + context[0].label;
            },
            label: function(context) {
              return 'Max cận lâm sàng: ' + context.parsed.y + ' người';
            }
          }
        }
      },
      scales: {
        x: {
          grid: {
            display: false
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            }
          }
        },
        y: {
          beginAtZero: true,
          grid: {
            color: 'rgba(0, 0, 0, 0.1)'
          },
          ticks: {
            color: '#64748b',
            font: {
              size: 12
            },
            callback: function(value) {
              return value + ' người';
            }
          }
        }
      }
    }
  });
}

function prepareChartData(data) {
  if (!data || !data.timeline || !data.timeline.dates || !data.timeline.rows || !data.timeline.weekdays) {
    return { labels: [], totalPeople: [] };
  }
  
  const labels = [];
  const totalPeople = [];
  
  // Calculate daily totals from timeline data
  const dailyTotals = new Array(data.timeline.dates.length).fill(0);
  
  // Sum up all companies for each day
  data.timeline.rows.forEach(row => {
    row.data.forEach((value, dayIndex) => {
      dailyTotals[dayIndex] += value;
    });
  });
  
  // Create chart data, excluding Sundays
  data.timeline.dates.forEach((date, index) => {
    const weekday = data.timeline.weekdays[index];
    // Skip Sundays (CN = Chủ nhật)
    if (weekday !== 'CN') {
      labels.push(date.toString());
      totalPeople.push(dailyTotals[index]);
    }
  });
  
  return { labels, totalPeople };
}

function prepareClinicalChartData(data) {
  if (!data || !data.data || !data.columns) {
    return { labels: [], maxValues: [] };
  }
  
  const labels = [];
  const maxValues = [];
  
  // Filter and sort data based on current filters
  let filteredData = data.data.slice();
  
  // Apply time filter
  if (timeFilter && timeFilter !== 'all') {
    const today = new Date();
    filteredData = filteredData.filter(row => {
      switch (timeFilter) {
        case 'today':
          const currentDate = today.getDate().toString().padStart(2, '0') + '/' + 
                             (today.getMonth() + 1).toString().padStart(2, '0') + '/' + 
                             today.getFullYear();
          return row.date === currentDate;
        case 'week':
          const weekAgo = new Date();
          weekAgo.setDate(today.getDate() - 7);
          const dateParts = row.date.split('/');
          if (dateParts.length === 3) {
            const rowDate = new Date(parseInt(dateParts[2]), parseInt(dateParts[1]) - 1, parseInt(dateParts[0]));
            return rowDate >= weekAgo && rowDate <= today;
          }
          return false;
        case 'month':
          return true;
        default:
          return true;
      }
    });
  }
  
  // Sort by date
  filteredData.sort((a, b) => {
    const dateA = parseInt(a.dateKey);
    const dateB = parseInt(b.dateKey);
    return dateA - dateB;
  });
  
  filteredData.forEach(row => {
    // Extract day from date (DD/MM/YYYY -> DD)
    const dayPart = row.date.split('/')[0];
    labels.push(dayPart);
    
    // Calculate max value for this day based on current shift filter
    let maxValue = 0;
    
    data.columns.forEach(col => {
      const value = row[col.key] || 0;
      
      // Apply shift filter
      if (shiftFilter === 'total' || 
          (shiftFilter === 'sang' && col.shift === 'morning') ||
          (shiftFilter === 'chieu' && col.shift === 'afternoon')) {
        if (value > maxValue) {
          maxValue = value;
        }
      }
    });
    
    maxValues.push(maxValue);
  });
  
  return { labels, maxValues };
}

// Update charts when data changes
function updateCharts() {
  if (dashboardData) {
    createTotalPeopleChart(dashboardData);
  }
  
  if (clinicalData) {
    createClinicalMaxChart(clinicalData);
  }
}

</script>